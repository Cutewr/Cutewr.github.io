<!doctype html>
<html lang="zh-CN" data-theme="light">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="generator" content="VuePress 2.0.0-rc.14" />
    <meta name="theme" content="VuePress Theme Hope 2.0.0-rc.52" />
    <style>
      html {
        background: var(--bg-color, #fff);
      }

      html[data-theme="dark"] {
        background: var(--bg-color, #1d1e1f);
      }

      body {
        background: var(--bg-color);
      }
    </style>
    <script>
      const userMode = localStorage.getItem("vuepress-theme-hope-scheme");
      const systemDarkMode =
        window.matchMedia &&
        window.matchMedia("(prefers-color-scheme: dark)").matches;

      if (userMode === "dark" || (userMode !== "light" && systemDarkMode)) {
        document.documentElement.setAttribute("data-theme", "dark");
      }
    </script>
    <meta property="og:url" content="https://cutewr.github.io/posts/Java/JavaCollection.html"><meta property="og:site_name" content="首页"><meta property="og:title" content="Java集合"><meta property="og:description" content="Java集合 Java集合概览 介绍一下Java中的集合框架 Java 集合，主要是由两大接口派生而来：一个是 Collection接口；另一个是 Map 接口。Collection 接口，下面又有三个子接口：List、Set 、 Queue。 List中常见的实现类有：ArrayList和LinkedList两个；Set接口实现常见类有HashSet..."><meta property="og:type" content="article"><meta property="og:image" content="https://cdn.nlark.com/yuque/0/2024/png/39067949/1719322039413-937c26d4-36e2-4404-8e4b-ae8b0ca38947.png"><meta property="og:locale" content="zh-CN"><meta property="og:updated_time" content="2024-08-28T10:16:51.000Z"><meta property="article:author" content="Cutewr"><meta property="article:published_time" content="2024-08-28T00:00:00.000Z"><meta property="article:modified_time" content="2024-08-28T10:16:51.000Z"><script type="application/ld+json">{"@context":"https://schema.org","@type":"Article","headline":"Java集合","image":["https://cdn.nlark.com/yuque/0/2024/png/39067949/1719322039413-937c26d4-36e2-4404-8e4b-ae8b0ca38947.png","https://cdn.nlark.com/yuque/0/2024/png/39067949/1719145462721-61e7012e-463b-4773-bcca-9bd61734f6a2.png"],"datePublished":"2024-08-28T00:00:00.000Z","dateModified":"2024-08-28T10:16:51.000Z","author":[{"@type":"Person","name":"Cutewr","url":"https://cutewr.github.io"}]}</script><title>Java集合 | 首页</title><meta name="description" content="Java集合 Java集合概览 介绍一下Java中的集合框架 Java 集合，主要是由两大接口派生而来：一个是 Collection接口；另一个是 Map 接口。Collection 接口，下面又有三个子接口：List、Set 、 Queue。 List中常见的实现类有：ArrayList和LinkedList两个；Set接口实现常见类有HashSet...">
    <link rel="stylesheet" href="/assets/css/styles.8aad64f1.css">
    <link rel="preload" href="/assets/js/runtime~app.0200d20d.js" as="script"><link rel="preload" href="/assets/css/styles.8aad64f1.css" as="style"><link rel="preload" href="/assets/js/4438.c841338e.js" as="script"><link rel="preload" href="/assets/js/app.fa5d547b.js" as="script">
    <link rel="prefetch" href="/assets/js/posts_LCNotes_7tree.html.5e255a0e.js" as="script"><link rel="prefetch" href="/assets/js/posts_Java_JUC.html.d3e5183f.js" as="script"><link rel="prefetch" href="/assets/js/posts_LCNotes_4linkedlist.html.32a06e29.js" as="script"><link rel="prefetch" href="/assets/js/posts_LCNotes_8graph.html.65dd7ec2.js" as="script"><link rel="prefetch" href="/assets/js/posts_LCNotes_1array.html.8aaaf820.js" as="script"><link rel="prefetch" href="/assets/js/posts_LCNotes_3hash.html.66f7906f.js" as="script"><link rel="prefetch" href="/assets/js/posts_Java_JavaCollection.html.b814846f.js" as="script"><link rel="prefetch" href="/assets/js/posts_Java_JavaBasic.html.5a03727e.js" as="script"><link rel="prefetch" href="/assets/js/posts_LCNotes_matrix.html.5929ca0f.js" as="script"><link rel="prefetch" href="/assets/js/posts_Java_JVM.html.c4d214cd.js" as="script"><link rel="prefetch" href="/assets/js/posts_LCNotes_5stack.html.18d6c7e2.js" as="script"><link rel="prefetch" href="/assets/js/photo-swipe.c88fb83d.js" as="script"><link rel="prefetch" href="/assets/js/posts_LCNotes_6double.html.f8f2c669.js" as="script"><link rel="prefetch" href="/assets/js/demo_markdown.html.562e5fab.js" as="script"><link rel="prefetch" href="/assets/js/posts_interview_knows.html.5c55843c.js" as="script"><link rel="prefetch" href="/assets/js/demo_page.html.35edf1e9.js" as="script"><link rel="prefetch" href="/assets/js/posts_RPC.html.83dd8b9c.js" as="script"><link rel="prefetch" href="/assets/js/intro.html.c0072430.js" as="script"><link rel="prefetch" href="/assets/js/demo_layout.html.bbe229a0.js" as="script"><link rel="prefetch" href="/assets/js/index.html.39511f22.js" as="script"><link rel="prefetch" href="/assets/js/posts_408_OS.html.c0756cfb.js" as="script"><link rel="prefetch" href="/assets/js/posts_tomato.html.bb0f1047.js" as="script"><link rel="prefetch" href="/assets/js/demo_disable.html.bc8cf5a7.js" as="script"><link rel="prefetch" href="/assets/js/posts_MySQL_4transaction.html.76f17937.js" as="script"><link rel="prefetch" href="/assets/js/posts_MySQL_1basic.html.28ac6fcb.js" as="script"><link rel="prefetch" href="/assets/js/posts_MySQL_2index.html.391e5628.js" as="script"><link rel="prefetch" href="/assets/js/posts_MySQL_3log.html.ddc78116.js" as="script"><link rel="prefetch" href="/assets/js/demo_index.html.37198165.js" as="script"><link rel="prefetch" href="/assets/js/demo_encrypt.html.8f0d9ca9.js" as="script"><link rel="prefetch" href="/assets/js/posts_interview_algorithm.html.57b08ade.js" as="script"><link rel="prefetch" href="/assets/js/category_使用指南_index.html.2d32f5c4.js" as="script"><link rel="prefetch" href="/assets/js/category_刷题笔记_index.html.925a7f3f.js" as="script"><link rel="prefetch" href="/assets/js/category_操作系统_index.html.cd6f642b.js" as="script"><link rel="prefetch" href="/assets/js/category_面试复盘_index.html.4fd5abbd.js" as="script"><link rel="prefetch" href="/assets/js/tag_使用指南_index.html.05a97273.js" as="script"><link rel="prefetch" href="/assets/js/tag_栈和队列_index.html.de8ace40.js" as="script"><link rel="prefetch" href="/assets/js/tag_进程管理_index.html.9c0d3788.js" as="script"><link rel="prefetch" href="/assets/js/tag_页面配置_index.html.ac01b5f0.js" as="script"><link rel="prefetch" href="/assets/js/category_中间件_index.html.0d636579.js" as="script"><link rel="prefetch" href="/assets/js/category_java基础_index.html.6d71e868.js" as="script"><link rel="prefetch" href="/assets/js/category_java集合_index.html.ad5fef9a.js" as="script"><link rel="prefetch" href="/assets/js/tag_mysql基础_index.html.a4bb66a1.js" as="script"><link rel="prefetch" href="/assets/js/tag_双指针_index.html.f1c0be91.js" as="script"><link rel="prefetch" href="/assets/js/tag_哈希表_index.html.beddd08a.js" as="script"><link rel="prefetch" href="/assets/js/tag_java基础_index.html.4aab4e1f.js" as="script"><link rel="prefetch" href="/assets/js/category_指南_index.html.c315bf03.js" as="script"><link rel="prefetch" href="/assets/js/category_蔬菜_index.html.daf11b52.js" as="script"><link rel="prefetch" href="/assets/js/tag_事务_index.html.795880d0.js" as="script"><link rel="prefetch" href="/assets/js/tag_八股_index.html.87343ea3.js" as="script"><link rel="prefetch" href="/assets/js/tag_加密_index.html.b7d8beaf.js" as="script"><link rel="prefetch" href="/assets/js/tag_数组_index.html.f87ee027.js" as="script"><link rel="prefetch" href="/assets/js/tag_禁用_index.html.21c3e790.js" as="script"><link rel="prefetch" href="/assets/js/tag_索引_index.html.3185103a.js" as="script"><link rel="prefetch" href="/assets/js/tag_项目_index.html.5e16e0fd.js" as="script"><link rel="prefetch" href="/assets/js/tag_布局_index.html.3352758a.js" as="script"><link rel="prefetch" href="/assets/js/tag_日志_index.html.327f39a2.js" as="script"><link rel="prefetch" href="/assets/js/tag_矩阵_index.html.fe16bd02.js" as="script"><link rel="prefetch" href="/assets/js/tag_算法_index.html.d84c2c86.js" as="script"><link rel="prefetch" href="/assets/js/tag_链表_index.html.904bb66d.js" as="script"><link rel="prefetch" href="/assets/js/tag_markdown_index.html.20ec1656.js" as="script"><link rel="prefetch" href="/assets/js/category_mysql_index.html.6f69e1bd.js" as="script"><link rel="prefetch" href="/assets/js/category_java_index.html.1281608c.js" as="script"><link rel="prefetch" href="/assets/js/tag_图_index.html.c6f393cc.js" as="script"><link rel="prefetch" href="/assets/js/tag_圆_index.html.e36886ba.js" as="script"><link rel="prefetch" href="/assets/js/tag_树_index.html.69ace5c8.js" as="script"><link rel="prefetch" href="/assets/js/tag_红_index.html.a2b93ecc.js" as="script"><link rel="prefetch" href="/assets/js/tag_jvm_index.html.86ab4300.js" as="script"><link rel="prefetch" href="/assets/js/tag_rpc_index.html.ee4a0586.js" as="script"><link rel="prefetch" href="/assets/js/404.html.529114c1.js" as="script"><link rel="prefetch" href="/assets/js/timeline_index.html.cfa9054b.js" as="script"><link rel="prefetch" href="/assets/js/category_index.html.8575cd5e.js" as="script"><link rel="prefetch" href="/assets/js/article_index.html.9bef6f34.js" as="script"><link rel="prefetch" href="/assets/js/tag_index.html.71441b74.js" as="script"><link rel="prefetch" href="/assets/js/star_index.html.29fa8c28.js" as="script"><link rel="prefetch" href="/assets/js/posts_LCNotes_index.html.e19362b1.js" as="script"><link rel="prefetch" href="/assets/js/posts_MySQL_index.html.292bbc2c.js" as="script"><link rel="prefetch" href="/assets/js/posts_Java_index.html.544bde1f.js" as="script"><link rel="prefetch" href="/assets/js/posts_408_index.html.563d53f5.js" as="script"><link rel="prefetch" href="/assets/js/posts_index.html.026d82cc.js" as="script"><link rel="prefetch" href="/assets/js/posts_interview_project.html.c867de98.js" as="script"><link rel="prefetch" href="/assets/js/posts_interview_index.html.a5159fb4.js" as="script">
  </head>
  <body>
    <div id="app"><!--[--><!--[--><!--[--><span tabindex="-1"></span><a href="#main-content" class="vp-skip-link sr-only">跳至主要內容</a><!--]--><div class="theme-container external-link-icon has-toc"><!--[--><header id="navbar" class="vp-navbar"><div class="vp-navbar-start"><button type="button" class="vp-toggle-sidebar-button" title="Toggle Sidebar"><span class="icon"></span></button><!----><!--[--><a class="route-link vp-brand" href="/"><img class="vp-nav-logo" src="/assets/icon/logo_round.png" alt><!----><span class="vp-site-name hide-in-pad">首页</span></a><!--]--><!----></div><div class="vp-navbar-center"><!----><!--[--><nav class="vp-nav-links"><div class="vp-nav-item hide-in-mobile"><a class="route-link auto-link" href="/" aria-label="Cutewr&#39;s Blog"><!--[--><span class="font-icon icon fa-fw fa-sm fas fa-home" style=""></span><!--]-->Cutewr&#39;s Blog<!----></a></div><div class="vp-nav-item hide-in-mobile"><a class="route-link auto-link" href="/demo/" aria-label="主要功能与配置演示"><!--[--><span class="font-icon icon fa-fw fa-sm fas fa-laptop-code" style=""></span><!--]-->主要功能与配置演示<!----></a></div><div class="vp-nav-item hide-in-mobile"><div class="vp-dropdown-wrapper"><button type="button" class="vp-dropdown-title" aria-label="Java"><!--[--><!---->Java<!--]--><span class="arrow"></span><ul class="vp-dropdown"><li class="vp-dropdown-item"><a class="route-link auto-link" href="/posts/Java/JavaBasic.html" aria-label="Java基础"><!---->Java基础<!----></a></li><li class="vp-dropdown-item"><a class="route-link route-link-active auto-link" href="/posts/Java/JavaCollection.html" aria-label="Java集合"><!---->Java集合<!----></a></li><li class="vp-dropdown-item"><a class="route-link auto-link" href="/posts/Java/JUC.html" aria-label="Java并发编程"><!---->Java并发编程<!----></a></li><li class="vp-dropdown-item"><a class="route-link auto-link" href="/posts/Java/JVM.html" aria-label="Java虚拟机"><!---->Java虚拟机<!----></a></li></ul></button></div></div><div class="vp-nav-item hide-in-mobile"><div class="vp-dropdown-wrapper"><button type="button" class="vp-dropdown-title" aria-label="刷题笔记"><!--[--><!---->刷题笔记<!--]--><span class="arrow"></span><ul class="vp-dropdown"><li class="vp-dropdown-item"><a class="route-link auto-link" href="/posts/LCNotes/1array.html" aria-label="数组"><!---->数组<!----></a></li><li class="vp-dropdown-item"><a class="route-link auto-link" href="/posts/LCNotes/matrix.html" aria-label="矩阵【二维数组】"><!---->矩阵【二维数组】<!----></a></li><li class="vp-dropdown-item"><a class="route-link auto-link" href="/posts/LCNotes/3hash.html" aria-label="哈希表"><!---->哈希表<!----></a></li><li class="vp-dropdown-item"><a class="route-link auto-link" href="/posts/LCNotes/4linkedlist.html" aria-label="链表"><!---->链表<!----></a></li><li class="vp-dropdown-item"><a class="route-link auto-link" href="/posts/LCNotes/5stack.html" aria-label="栈和队列"><!---->栈和队列<!----></a></li><li class="vp-dropdown-item"><a class="route-link auto-link" href="/posts/LCNotes/6double.html" aria-label="双指针"><!---->双指针<!----></a></li><li class="vp-dropdown-item"><a class="route-link auto-link" href="/posts/LCNotes/7tree.html" aria-label="树"><!---->树<!----></a></li><li class="vp-dropdown-item"><a class="route-link auto-link" href="/posts/LCNotes/8graph.html" aria-label="图"><!---->图<!----></a></li></ul></button></div></div><div class="vp-nav-item hide-in-mobile"><div class="vp-dropdown-wrapper"><button type="button" class="vp-dropdown-title" aria-label="MySQL"><!--[--><!---->MySQL<!--]--><span class="arrow"></span><ul class="vp-dropdown"><li class="vp-dropdown-item"><a class="route-link auto-link" href="/posts/MySQL/1basic.html" aria-label="MySQL基础"><!---->MySQL基础<!----></a></li><li class="vp-dropdown-item"><a class="route-link auto-link" href="/posts/MySQL/2index.html" aria-label="MySQL索引"><!---->MySQL索引<!----></a></li><li class="vp-dropdown-item"><a class="route-link auto-link" href="/posts/MySQL/3log.html" aria-label="MySQL日志"><!---->MySQL日志<!----></a></li><li class="vp-dropdown-item"><a class="route-link auto-link" href="/posts/MySQL/4transaction.html" aria-label="MySQL事务"><!---->MySQL事务<!----></a></li></ul></button></div></div><div class="vp-nav-item hide-in-mobile"><div class="vp-dropdown-wrapper"><button type="button" class="vp-dropdown-title" aria-label="非关系型数据库"><!--[--><!---->非关系型数据库<!--]--><span class="arrow"></span><ul class="vp-dropdown"><li class="vp-dropdown-item"><a class="route-link auto-link" href="/1.html" aria-label="矩阵【二维数组】"><!--[--><span class="font-icon icon fa-fw fa-sm fas fa-pen-to-square" style=""></span><!--]-->矩阵【二维数组】<!----></a></li><li class="vp-dropdown-item"><a class="route-link auto-link" href="/2.html" aria-label="香蕉 2"><!--[--><span class="font-icon icon fa-fw fa-sm fas fa-pen-to-square" style=""></span><!--]-->香蕉 2<!----></a></li></ul></button></div></div><div class="vp-nav-item hide-in-mobile"><div class="vp-dropdown-wrapper"><button type="button" class="vp-dropdown-title" aria-label="计算机基础"><!--[--><!---->计算机基础<!--]--><span class="arrow"></span><ul class="vp-dropdown"><li class="vp-dropdown-item"><h4 class="vp-dropdown-subtitle">计算机网络</h4><ul class="vp-dropdown-subitems"><li class="vp-dropdown-subitem"><a class="route-link auto-link" href="/apple/1.html" aria-label="苹果1"><!---->苹果1<!----></a></li><li class="vp-dropdown-subitem"><a class="route-link auto-link" href="/apple/2.html" aria-label="苹果2"><!---->苹果2<!----></a></li></ul></li><li class="vp-dropdown-item"><h4 class="vp-dropdown-subtitle">操作系统</h4><ul class="vp-dropdown-subitems"><li class="vp-dropdown-subitem"><a class="route-link auto-link" href="/Java/1.html" aria-label="进程管理"><!---->进程管理<!----></a></li><li class="vp-dropdown-subitem"><a class="route-link auto-link" href="/Java/2.html" aria-label="苹果2"><!---->苹果2<!----></a></li></ul></li></ul></button></div></div><div class="vp-nav-item hide-in-mobile"><div class="vp-dropdown-wrapper"><button type="button" class="vp-dropdown-title" aria-label="面试复盘"><!--[--><!---->面试复盘<!--]--><span class="arrow"></span><ul class="vp-dropdown"><li class="vp-dropdown-item"><a class="route-link auto-link" href="/posts/interview/knows.html" aria-label="八股问答"><!---->八股问答<!----></a></li><li class="vp-dropdown-item"><a class="route-link auto-link" href="/posts/interview/project.html" aria-label="项目问答"><!---->项目问答<!----></a></li><li class="vp-dropdown-item"><a class="route-link auto-link" href="/posts/interview/algorithm.html" aria-label="算法题"><!---->算法题<!----></a></li></ul></button></div></div><div class="vp-nav-item hide-in-mobile"><div class="vp-dropdown-wrapper"><button type="button" class="vp-dropdown-title" aria-label="其他博文"><!--[--><span class="font-icon icon fa-fw fa-sm fas fa-pen-to-square" style=""></span>其他博文<!--]--><span class="arrow"></span><ul class="vp-dropdown"></ul></button></div></div></nav><!--]--><!----></div><div class="vp-navbar-end"><!----><!--[--><!----><div class="vp-nav-item vp-action"><a class="vp-action-link" href="https://github.com/Cutewr" target="_blank" rel="noopener noreferrer" aria-label="GitHub"><svg xmlns="http://www.w3.org/2000/svg" class="icon github-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="github icon" name="github" style="width:1.25rem;height:1.25rem;vertical-align:middle;"><path d="M511.957 21.333C241.024 21.333 21.333 240.981 21.333 512c0 216.832 140.544 400.725 335.574 465.664 24.49 4.395 32.256-10.07 32.256-23.083 0-11.69.256-44.245 0-85.205-136.448 29.61-164.736-64.64-164.736-64.64-22.315-56.704-54.4-71.765-54.4-71.765-44.587-30.464 3.285-29.824 3.285-29.824 49.195 3.413 75.179 50.517 75.179 50.517 43.776 75.008 114.816 53.333 142.762 40.79 4.523-31.66 17.152-53.377 31.19-65.537-108.971-12.458-223.488-54.485-223.488-242.602 0-53.547 19.114-97.323 50.517-131.67-5.035-12.33-21.93-62.293 4.779-129.834 0 0 41.258-13.184 134.912 50.346a469.803 469.803 0 0 1 122.88-16.554c41.642.213 83.626 5.632 122.88 16.554 93.653-63.488 134.784-50.346 134.784-50.346 26.752 67.541 9.898 117.504 4.864 129.834 31.402 34.347 50.474 78.123 50.474 131.67 0 188.586-114.73 230.016-224.042 242.09 17.578 15.232 33.578 44.672 33.578 90.454v135.85c0 13.142 7.936 27.606 32.854 22.87C862.25 912.597 1002.667 728.747 1002.667 512c0-271.019-219.648-490.667-490.71-490.667z"></path></svg></a></div><div class="vp-nav-item hide-in-mobile"><button type="button" class="vp-color-mode-switch" id="color-mode-switch"><svg xmlns="http://www.w3.org/2000/svg" class="icon auto-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="auto icon" name="auto" style="display:block;"><path d="M512 992C246.92 992 32 777.08 32 512S246.92 32 512 32s480 214.92 480 480-214.92 480-480 480zm0-840c-198.78 0-360 161.22-360 360 0 198.84 161.22 360 360 360s360-161.16 360-360c0-198.78-161.22-360-360-360zm0 660V212c165.72 0 300 134.34 300 300 0 165.72-134.28 300-300 300z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon dark-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="dark icon" name="dark" style="display:none;"><path d="M524.8 938.667h-4.267a439.893 439.893 0 0 1-313.173-134.4 446.293 446.293 0 0 1-11.093-597.334A432.213 432.213 0 0 1 366.933 90.027a42.667 42.667 0 0 1 45.227 9.386 42.667 42.667 0 0 1 10.24 42.667 358.4 358.4 0 0 0 82.773 375.893 361.387 361.387 0 0 0 376.747 82.774 42.667 42.667 0 0 1 54.187 55.04 433.493 433.493 0 0 1-99.84 154.88 438.613 438.613 0 0 1-311.467 128z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon light-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="light icon" name="light" style="display:none;"><path d="M952 552h-80a40 40 0 0 1 0-80h80a40 40 0 0 1 0 80zM801.88 280.08a41 41 0 0 1-57.96-57.96l57.96-58a41.04 41.04 0 0 1 58 58l-58 57.96zM512 752a240 240 0 1 1 0-480 240 240 0 0 1 0 480zm0-560a40 40 0 0 1-40-40V72a40 40 0 0 1 80 0v80a40 40 0 0 1-40 40zm-289.88 88.08-58-57.96a41.04 41.04 0 0 1 58-58l57.96 58a41 41 0 0 1-57.96 57.96zM192 512a40 40 0 0 1-40 40H72a40 40 0 0 1 0-80h80a40 40 0 0 1 40 40zm30.12 231.92a41 41 0 0 1 57.96 57.96l-57.96 58a41.04 41.04 0 0 1-58-58l58-57.96zM512 832a40 40 0 0 1 40 40v80a40 40 0 0 1-80 0v-80a40 40 0 0 1 40-40zm289.88-88.08 58 57.96a41.04 41.04 0 0 1-58 58l-57.96-58a41 41 0 0 1 57.96-57.96z"></path></svg></button></div><!----><!--]--><!----><button type="button" class="vp-toggle-navbar-button" aria-label="Toggle Navbar" aria-expanded="false" aria-controls="nav-screen"><span><span class="vp-top"></span><span class="vp-middle"></span><span class="vp-bottom"></span></span></button></div></header><!----><!--]--><!----><div class="toggle-sidebar-wrapper"><span class="arrow start"></span></div><aside id="sidebar" class="vp-sidebar"><!----><ul class="vp-sidebar-links"><li><section class="vp-sidebar-group"><p class="vp-sidebar-header active"><span class="font-icon icon fa-fw fa-sm fas fa-book" style=""></span><span class="vp-sidebar-title">Java</span><!----></p><ul class="vp-sidebar-links"><li><a class="route-link auto-link vp-sidebar-link" href="/posts/Java/JavaBasic.html" aria-label="Java基础"><!--[--><span class="font-icon icon fa-fw fa-sm fas fa-pen-to-square" style=""></span><!--]-->Java基础<!----></a></li><li><a class="route-link route-link-active auto-link vp-sidebar-link active" href="/posts/Java/JavaCollection.html" aria-label="Java集合"><!--[--><span class="font-icon icon fa-fw fa-sm fas fa-pen-to-square" style=""></span><!--]-->Java集合<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/posts/Java/JUC.html" aria-label="JUC并发编程"><!--[--><span class="font-icon icon fa-fw fa-sm fas fa-pen-to-square" style=""></span><!--]-->JUC并发编程<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/posts/Java/JVM.html" aria-label="JVM"><!--[--><span class="font-icon icon fa-fw fa-sm fas fa-pen-to-square" style=""></span><!--]-->JVM<!----></a></li></ul></section></li></ul><!----></aside><!--[--><main id="main-content" class="vp-page"><!--[--><!----><!----><nav class="vp-breadcrumb disable"></nav><div class="vp-page-title"><h1><span class="font-icon icon fa-fw fa-sm fas fa-pen-to-square" style=""></span>Java集合</h1><div class="page-info"><span class="page-author-info" aria-label="作者🖊" data-balloon-pos="up"><svg xmlns="http://www.w3.org/2000/svg" class="icon author-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="author icon" name="author"><path d="M649.6 633.6c86.4-48 147.2-144 147.2-249.6 0-160-128-288-288-288s-288 128-288 288c0 108.8 57.6 201.6 147.2 249.6-121.6 48-214.4 153.6-240 288-3.2 9.6 0 19.2 6.4 25.6 3.2 9.6 12.8 12.8 22.4 12.8h704c9.6 0 19.2-3.2 25.6-12.8 6.4-6.4 9.6-16 6.4-25.6-25.6-134.4-121.6-240-243.2-288z"></path></svg><span><a class="page-author-item" href="https://cutewr.github.io" target="_blank" rel="noopener noreferrer">Cutewr</a></span><span property="author" content="Cutewr"></span></span><!----><span class="page-date-info" aria-label="写作日期📅" data-balloon-pos="up"><svg xmlns="http://www.w3.org/2000/svg" class="icon calendar-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="calendar icon" name="calendar"><path d="M716.4 110.137c0-18.753-14.72-33.473-33.472-33.473-18.753 0-33.473 14.72-33.473 33.473v33.473h66.993v-33.473zm-334.87 0c0-18.753-14.72-33.473-33.473-33.473s-33.52 14.72-33.52 33.473v33.473h66.993v-33.473zm468.81 33.52H716.4v100.465c0 18.753-14.72 33.473-33.472 33.473a33.145 33.145 0 01-33.473-33.473V143.657H381.53v100.465c0 18.753-14.72 33.473-33.473 33.473a33.145 33.145 0 01-33.473-33.473V143.657H180.6A134.314 134.314 0 0046.66 277.595v535.756A134.314 134.314 0 00180.6 947.289h669.74a134.36 134.36 0 00133.94-133.938V277.595a134.314 134.314 0 00-133.94-133.938zm33.473 267.877H147.126a33.145 33.145 0 01-33.473-33.473c0-18.752 14.72-33.473 33.473-33.473h736.687c18.752 0 33.472 14.72 33.472 33.473a33.145 33.145 0 01-33.472 33.473z"></path></svg><span><!----></span><meta property="datePublished" content="2024-08-28T00:00:00.000Z"></span><!----><span class="page-reading-time-info" aria-label="阅读时间⌛" data-balloon-pos="up"><svg xmlns="http://www.w3.org/2000/svg" class="icon timer-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="timer icon" name="timer"><path d="M799.387 122.15c4.402-2.978 7.38-7.897 7.38-13.463v-1.165c0-8.933-7.38-16.312-16.312-16.312H256.33c-8.933 0-16.311 7.38-16.311 16.312v1.165c0 5.825 2.977 10.874 7.637 13.592 4.143 194.44 97.22 354.963 220.201 392.763-122.204 37.542-214.893 196.511-220.2 389.397-4.661 5.049-7.638 11.651-7.638 19.03v5.825h566.49v-5.825c0-7.379-2.849-13.981-7.509-18.9-5.049-193.016-97.867-351.985-220.2-389.527 123.24-37.67 216.446-198.453 220.588-392.892zM531.16 450.445v352.632c117.674 1.553 211.787 40.778 211.787 88.676H304.097c0-48.286 95.149-87.382 213.728-88.676V450.445c-93.077-3.107-167.901-81.297-167.901-177.093 0-8.803 6.99-15.793 15.793-15.793 8.803 0 15.794 6.99 15.794 15.793 0 80.261 63.69 145.635 142.01 145.635s142.011-65.374 142.011-145.635c0-8.803 6.99-15.793 15.794-15.793s15.793 6.99 15.793 15.793c0 95.019-73.789 172.82-165.96 177.093z"></path></svg><span>大约 29 分钟</span><meta property="timeRequired" content="PT29M"></span><span class="page-category-info" aria-label="分类🌈" data-balloon-pos="up"><svg xmlns="http://www.w3.org/2000/svg" class="icon category-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="category icon" name="category"><path d="M148.41 106.992h282.176c22.263 0 40.31 18.048 40.31 40.31V429.48c0 22.263-18.047 40.31-40.31 40.31H148.41c-22.263 0-40.311-18.047-40.311-40.31V147.302c0-22.263 18.048-40.31 40.311-40.31zM147.556 553.478H429.73c22.263 0 40.311 18.048 40.311 40.31v282.176c0 22.263-18.048 40.312-40.31 40.312H147.555c-22.263 0-40.311-18.049-40.311-40.312V593.79c0-22.263 18.048-40.311 40.31-40.311zM593.927 106.992h282.176c22.263 0 40.31 18.048 40.31 40.31V429.48c0 22.263-18.047 40.31-40.31 40.31H593.927c-22.263 0-40.311-18.047-40.311-40.31V147.302c0-22.263 18.048-40.31 40.31-40.31zM730.22 920.502H623.926c-40.925 0-74.22-33.388-74.22-74.425V623.992c0-41.038 33.387-74.424 74.425-74.424h222.085c41.038 0 74.424 33.226 74.424 74.067v114.233c0 10.244-8.304 18.548-18.547 18.548s-18.548-8.304-18.548-18.548V623.635c0-20.388-16.746-36.974-37.33-36.974H624.13c-20.585 0-37.331 16.747-37.331 37.33v222.086c0 20.585 16.654 37.331 37.126 37.331H730.22c10.243 0 18.547 8.304 18.547 18.547 0 10.244-8.304 18.547-18.547 18.547z"></path></svg><!--[--><span class="page-category-item color1 clickable" role="navigation">Java集合</span><!--]--><meta property="articleSection" content="Java集合"></span><!----></div><hr></div><div class="vp-toc-placeholder"><aside id="toc"><!----><div class="vp-toc-header">此页内容<button type="button" class="print-button" title="打印"><svg xmlns="http://www.w3.org/2000/svg" class="icon print-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="print icon" name="print"><path d="M819.2 364.8h-44.8V128c0-17.067-14.933-32-32-32H281.6c-17.067 0-32 14.933-32 32v236.8h-44.8C145.067 364.8 96 413.867 96 473.6v192c0 59.733 49.067 108.8 108.8 108.8h44.8V896c0 17.067 14.933 32 32 32h460.8c17.067 0 32-14.933 32-32V774.4h44.8c59.733 0 108.8-49.067 108.8-108.8v-192c0-59.733-49.067-108.8-108.8-108.8zM313.6 160h396.8v204.8H313.6V160zm396.8 704H313.6V620.8h396.8V864zM864 665.6c0 25.6-19.2 44.8-44.8 44.8h-44.8V588.8c0-17.067-14.933-32-32-32H281.6c-17.067 0-32 14.933-32 32v121.6h-44.8c-25.6 0-44.8-19.2-44.8-44.8v-192c0-25.6 19.2-44.8 44.8-44.8h614.4c25.6 0 44.8 19.2 44.8 44.8v192z"></path></svg></button><div class="arrow end"></div></div><div class="vp-toc-wrapper"><ul class="vp-toc-list"><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="#介绍一下java中的集合框架">介绍一下Java中的集合框架</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="#数组和链表的区别">数组和链表的区别</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="#说说-list-set-queue-map-四者的区别">说说 List, Set, Queue, Map 四者的区别？</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="#如何选用合适的集合">如何选用合适的集合</a></li><li><ul class="vp-toc-list"><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_1、list">1、List</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_2、set">2、Set</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_3、queue">3、Queue</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_4、map">4、Map</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="#arraylist和linkedlist的区别">ArrayList和LinkedList的区别</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="#arraylist和vector的区别">ArrayList和Vector的区别</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="#copyonwritearraylist">CopyOnWriteArrayList</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="#什么是java中的copy-on-write">什么是Java中的Copy On Write</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="#abstractlist">AbstractList</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="#arraylist和array-静态数组-的区别">ArrayList和Array(静态数组)的区别</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="#arraylist的扩容机制">ArrayList的扩容机制</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="#linkedlist的应用场景">LinkedList的应用场景</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="#有哪些线程安全的list接口实现类">有哪些线程安全的list接口实现类</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="#comparable-和-comparator-的区别">Comparable 和 Comparator 的区别</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="#比较-hashset、linkedhashset-和-treeset-三者的异同">比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="#treeset实现自定义排序">TreeSet实现自定义排序</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="#hashset和hashmap的区别">HashSet和HashMap的区别</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="#hashmap的扩容机制">HashMap的扩容机制</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="#为什么-hashmap-的容量是-2-的幂呢">为什么 HashMap 的容量是 2 的幂呢？</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="#什么是哈希冲突-怎么解决哈希冲突">什么是哈希冲突，怎么解决哈希冲突？</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="#hashmap的底层数据结构">Hashmap的底层数据结构</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="#为什么链表转成红黑树-直接用红黑树不就得了">为什么链表转成红黑树，直接用红黑树不就得了？</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="#为什么节点少于6要从红黑树变回链表">为什么节点少于6要从红黑树变回链表</a></li><li><ul class="vp-toc-list"><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#jdk1-7版本-分段锁">jdk1.7版本 分段锁</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#jdk1-8版本-cas-synchronized">jdk1.8版本 CAS+synchronized</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#get方法需要加锁吗">get方法需要加锁吗</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="#阻塞队列的特点">阻塞队列的特点</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="#阻塞队列的核心方法">阻塞队列的核心方法</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="#常见的阻塞队列">常见的阻塞队列</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="#阻塞队列的原理">阻塞队列的原理</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="#同步队列的使用场景">同步队列的使用场景</a></li><!----><!--]--></ul><div class="vp-toc-marker" style="top:-1.7rem;"></div></div><!----></aside></div><!----><div class="theme-hope-content"><h1 id="java集合" tabindex="-1"><a class="header-anchor" href="#java集合"><span>Java集合</span></a></h1><h1 id="java集合概览" tabindex="-1"><a class="header-anchor" href="#java集合概览"><span>Java集合概览</span></a></h1><h2 id="介绍一下java中的集合框架" tabindex="-1"><a class="header-anchor" href="#介绍一下java中的集合框架"><span>介绍一下Java中的集合框架</span></a></h2><p>Java 集合，主要是由两大接口派生而来：一个是 Collection接口；另一个是 Map 接口。Collection 接口，下面又有三个子接口：List、Set 、 Queue。</p><p>List中常见的实现类有：ArrayList和LinkedList两个；Set接口实现常见类有HashSet、LinkedHashSet、TreeSet；Queue接口的实现类有PriorityQueue优先级队列。</p><p>Map接口常见的实现类有HashMap、LinkedHashMap、TreeMap、Hashtable、ConcurrentHashMap。</p><h2 id="数组和链表的区别" tabindex="-1"><a class="header-anchor" href="#数组和链表的区别"><span>数组和链表的区别</span></a></h2><ol><li>存储结构：数组基于连续的内存块，大小是固定的，内存使用紧凑但容易浪费空间。链表是基于节点的结构，在内存中不需要连续存储，可以动态扩展。</li><li>访问速度：数组支持O(1)时间的随机访问，可以通过索引计算出元素的访问地址，直接访问元素。而链表访问特定元素需要O(n）时间复杂度，因为节点在内存中不一定连续，需要从链表头开始遍历。</li><li>插入和删除操作: 数组插入和删除都有可能影响整个数组，时间复杂度为O(n)。而链表则很灵活，可在O（1）时间插入和修改指定位骯素。</li></ol><p>因此数组适合需要快速随机访问并且修改操作较少的场景。链表适合需要频繁插入和删除操作的场景。</p><p>Java中最常见的数组和链表是ArrayList和LinkedList。</p><h2 id="说说-list-set-queue-map-四者的区别" tabindex="-1"><a class="header-anchor" href="#说说-list-set-queue-map-四者的区别"><span>说说 List, Set, Queue, Map 四者的区别？</span></a></h2><ul><li>List: 存储的元素是有序的、可重复的。</li><li>Set: 存储的元素不可重复的。</li><li>Queue: 按特定的排队规则来确定先后顺序，存储的元素是有序的、可重复的。</li><li>Map: 使用键值对（key-value）存储，key 是无序的、不可重复的，value 是无序的、可重复的，每个键最多映射到一个值。</li></ul><h2 id="如何选用合适的集合" tabindex="-1"><a class="header-anchor" href="#如何选用合适的集合"><span>如何选用合适的集合</span></a></h2><p>如果要存储键值对，就选用map接口下的实现类，如果要实现排序就用treemap，不需要就使用hashmap，需要线程安全就使用concurrenthashmap【不要使用hashtable，因为hashtable的线程安全实现是在方法前面加上synchronized关键字，无论什么请求会锁住整个哈希表，其他想操作hashtable的线程都会阻塞。而councurrentHashmap在jdk1.7和1.8之间有不同的实现，他们的锁的粒度都比hashtable小】。</p><p>不存储键值对，就用Collection接口下的集合。需要存储唯一的数据就用set接口下的实现类，比如hashset和treeset；不需要就可以使用list接口下的集合，比如arraylist和linkedlist；如果要实现特定的元素出入顺序，或者实现取出最大/最小元素这样的请求，可以使用queue接口下的实现类。</p><h1 id="集合框架底层数据结构" tabindex="-1"><a class="header-anchor" href="#集合框架底层数据结构"><span>集合框架底层数据结构</span></a></h1><h3 id="_1、list" tabindex="-1"><a class="header-anchor" href="#_1、list"><span>1、List</span></a></h3><ul><li>ArrayList：Object[] 数组。</li><li>Vector：Object[] 数组。</li><li>LinkedList：双向链表(JDK1.6 之前为循环链表，JDK1.7 取消了循环)。</li></ul><h3 id="_2、set" tabindex="-1"><a class="header-anchor" href="#_2、set"><span>2、Set</span></a></h3><ul><li>HashSet(无序，唯一): 基于 HashMap 实现的，将set中的元素添加到hashmap的key中，HashMap中的value都是存储的一样的,都是同一个Object对象(底层源码中:PRESENT)，private static final Object PRESENT = new Object()；【为了防止出现空指针异常】</li><li>LinkedHashSet: LinkedHashSet 是 HashSet 的子类，并且其内部是通过 LinkedHashMap 来实现的。【保证元素添加的顺序】</li><li>TreeSet(有序，唯一): 红黑树(自平衡的排序二叉树)。【保证元素的自然顺序和实现自定义排序】</li></ul><h3 id="_3、queue" tabindex="-1"><a class="header-anchor" href="#_3、queue"><span>3、Queue</span></a></h3><ul><li>PriorityQueue: Object[] 数组来实现小顶堆。</li><li>DelayQueue:PriorityQueue。</li><li>ArrayDeque: 可扩容动态双向数组。</li></ul><h3 id="_4、map" tabindex="-1"><a class="header-anchor" href="#_4、map"><span>4、Map</span></a></h3><ul><li>HashMap：JDK1.8 之前 HashMap 由数组+链表组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）。JDK1.8 以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。</li><li>LinkedHashMap：LinkedHashMap 继承自 HashMap，所以它的底层仍然是基于拉链式散列结构即由数组和链表或红黑树组成。另外，LinkedHashMap 在上面结构的基础上，增加了一条<strong>双向链表</strong>，使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。</li><li>Hashtable：数组+链表组成的，数组是 Hashtable 的主体，链表则是主要为了解决哈希冲突而存在的。</li><li>TreeMap：红黑树（自平衡的排序二叉树）。</li></ul><h1 id="list" tabindex="-1"><a class="header-anchor" href="#list"><span>List</span></a></h1><h2 id="arraylist和linkedlist的区别" tabindex="-1"><a class="header-anchor" href="#arraylist和linkedlist的区别"><span>ArrayList和LinkedList的区别</span></a></h2><p>List接口实现类中最常见的就是ArrayList和LinkedList，首先它们都不是线程安全的。</p><ol><li>ArrayList底层是Object[]数组，所以特性和数组一直，随机访问快，时间复杂度O(1)；插入和删除操作比较慢，时间复杂度O(n)</li><li>LinkedList底层是双向链表。两端插入和删除快，时间复杂度为O(1)；随机访问需要遍历链表，时间复杂度为O(n)</li><li>内存空间占用不同：ArrayList对空间的占用主要体现在列表的结尾会预留一定的空间。LinkedList对空间的占用主要体现在存放直接前驱和直接后继。</li></ol><h2 id="arraylist和vector的区别" tabindex="-1"><a class="header-anchor" href="#arraylist和vector的区别"><span>ArrayList和Vector的区别</span></a></h2><p>List接口还有一个实现是Vector，Vector也是基于动态数组实现的，但是方法前面加了synchronized关键字，是线程安全的。也因为同步开销比较大，因此性能相对较低。</p><p>但是这种给方法加synchronized的方式保证的线程安全不是绝对的，这种锁是方法级的。如果出现多个线程使用不同的方法，比如使用get和remove方法，就有可能造成访问数据的时候，数据已经被删除了，造成数组越界异常。因此使用vector做复杂操作时，还需要自己在程序中额外加锁。这时候应该使用arrayList，避免vector重复加锁影响性能。</p><h2 id="copyonwritearraylist" tabindex="-1"><a class="header-anchor" href="#copyonwritearraylist"><span>CopyOnWriteArrayList</span></a></h2><p>List的另一个实现是CopyOnWriteArrayList，基于动态数组实现，但所有可变操作(如add()、set() 等)都会创建一个新的数组，运用了copyOnWrite技术，在写的时候，拷贝一个新数组。它是线程安全的，适合在多线程环境中读多写少的场景。</p><h2 id="什么是java中的copy-on-write" tabindex="-1"><a class="header-anchor" href="#什么是java中的copy-on-write"><span>什么是Java中的Copy On Write</span></a></h2><p>我们都知道操作系统有父子进程的概念，当父进程创建子进程之后，父子进程的内存空间是共享的，只有当子进程(或父进程)尝试写入或修改数据的时候，才需要复制一个新的内存页面写入。</p><p>因为一开始共享内存，所以在没有发生修改的时候，内存不需要新复制一份，当写入的时候才发生复制，这就不仅节省内存，也避免了内存频繁复制的开销。</p><p>copy-on-write 对读比较友好，多个并发读可以共享，互相不会阻塞；当有线程写在修改数据的时候，也不会阻塞读，因为可以读老的数据。</p><p>不过 copy-0n-write 也有缺点，写操作会延迟，因为写的时候需要拷贝数据。</p><p>如果写操作非常频繁就会一直拷贝数据，开销比较大，所以它适合读多写少的场景。</p><p>在 Java 中主要有 copyonwriteArrayList 这个实现类，底层基于数组存储，写的时候会拷贝一个新数组。</p><p>它是线程安全的，读不会被写阻塞。</p><h2 id="abstractlist" tabindex="-1"><a class="header-anchor" href="#abstractlist"><span>AbstractList</span></a></h2><p>是一个抽象类,实现了List 接口的大部分方法，提供了基本的List功能。</p><p>如果我们想要扩展实现自己的列表，那么可以用它作为自定义列表实现的基础类，减少我们的自定义成本。</p><h2 id="arraylist和array-静态数组-的区别" tabindex="-1"><a class="header-anchor" href="#arraylist和array-静态数组-的区别"><span>ArrayList和Array(静态数组)的区别</span></a></h2><ol><li>ArrayList中能添加null值</li><li>Array初始化的时候必须指定大小，ArrayList不需要。</li><li>ArrayList可以根据实际需求，调用API()，增加/删除元素；而array只是一个固定长度的数组，只能按照下标获取元素，不具备动态增加、删除元素的能力。</li><li>ArrayList会根据实际存储的元素数量进行自动扩容，而Array创建后就不能改变长度了</li><li>ArrayList允许使用泛型来保证类型安全，Array不行</li><li>ArrayList只允许存放对象，对于基本数据类型，需要使用它们对应的包装类；而Array支持存储基本数据类型，也可以存储对象</li></ol><h2 id="arraylist的扩容机制" tabindex="-1"><a class="header-anchor" href="#arraylist的扩容机制"><span>ArrayList的扩容机制</span></a></h2><p>ArrayList默认初始长度是10，当然我们也可以在创建ArrayList时，指定初始长度。随着程序不断往ArrayList添加数据，当添加到第十一个数据时，ArrayList就会触发自动扩容机制。首先会计算出原来容量的1.5倍作为新容量，如果新容量还是小于最小需要容量，就把最小需要容量当做新容量。如果新容量超过了数组最大容量(Integer.MAX_VALUE-8),就把容量设置为Integer.Max_VALUE。然后利用Arrays.copyOf()这个方法创建新容量对应的数组，并把原数组中的元素复制到新数组中，原来数组的引用指向新数组。</p><h2 id="linkedlist的应用场景" tabindex="-1"><a class="header-anchor" href="#linkedlist的应用场景"><span>LinkedList的应用场景</span></a></h2><ol><li>适用于更多的插入和删除元素，更少的读取数据。因为插入和删除元素不涉及重排数据，所以它要比ArrayList要快。</li><li>可以用LinkedList实现的栈、队列、双端队列</li></ol><h2 id="有哪些线程安全的list接口实现类" tabindex="-1"><a class="header-anchor" href="#有哪些线程安全的list接口实现类"><span>有哪些线程安全的list接口实现类</span></a></h2><ol><li>使用Vector容器</li><li>使用Collections的静态方法synchronizedList(List&lt; T&gt; list)</li><li>采用CopyOnWriteArrayList容器【写操作时，会复制原来的数组并且在新数组上修改，最后再将原数组覆盖】</li></ol><h1 id="set" tabindex="-1"><a class="header-anchor" href="#set"><span>Set</span></a></h1><h2 id="comparable-和-comparator-的区别" tabindex="-1"><a class="header-anchor" href="#comparable-和-comparator-的区别"><span>Comparable 和 Comparator 的区别</span></a></h2><p>Comparable 接口和 Comparator 接口都是 Java 中用于排序的接口，它们在实现类对象之间比较大小、排序等方面发挥了重要作用：</p><ul><li>Comparable 接口实际上是出自java.lang包 它有一个 compareTo(Object obj)方法用来排序</li><li>Comparator接口实际上是出自 java.util 包它有一个compare(Object obj1, Object obj2)方法用来排序</li></ul><p>一般我们需要对一个集合使用自定义排序时，我们就要重写compareTo()方法或compare()方法。</p><p>【例子放在下面的treeset自定义排序】</p><h2 id="比较-hashset、linkedhashset-和-treeset-三者的异同" tabindex="-1"><a class="header-anchor" href="#比较-hashset、linkedhashset-和-treeset-三者的异同"><span>比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同</span></a></h2><ol><li>HashSet、LinkedHashSet 和 TreeSet 都是 Set 接口的实现类，都能保证元素唯一，并且都不是线程安全的。</li><li>HashSet、LinkedHashSet 和 TreeSet 的主要区别在于底层数据结构不同。HashSet 的底层数据结构是哈希表（基于 HashMap 实现）。LinkedHashSet 的底层数据结构是链表和哈希表，元素的插入和取出顺序满足 FIFO。TreeSet 底层数据结构是红黑树，元素是有序的，排序的方式有自然排序和定制排序。</li><li>底层数据结构不同又导致这三者的应用场景不同。HashSet 用于不需要保证元素插入和取出顺序的场景，LinkedHashSet 用于保证元素的插入和取出顺序满足 FIFO 的场景，TreeSet 用于支持对元素自定义排序规则的场景。</li></ol><h2 id="treeset实现自定义排序" tabindex="-1"><a class="header-anchor" href="#treeset实现自定义排序"><span>TreeSet实现自定义排序</span></a></h2><ol><li>使用java.util包下的comparator，自定义compare方法</li></ol><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> comparator</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">{</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> static</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> main</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">String</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[] </span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">args</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">        Person</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> p</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">new</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> Person</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">11</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">        Person</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> p1</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">new</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> Person</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">8</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">        Person</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> p2</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">new</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> Person</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">17</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">        Person</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> p3</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">new</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> Person</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">12</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">        TreeSet</span><span style="--shiki-light:#E45649;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Person</span><span style="--shiki-light:#E45649;--shiki-dark:#ABB2BF;">&gt; </span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">s</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">new</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> TreeSet</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;&gt;(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">new</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Comparator</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Person</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt;() {</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">            @</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">Override</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">            public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> int</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> compare</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Person</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;"> o1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Person</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;"> o2</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">                return</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> o1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">age</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">-</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">o2</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">age</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">            }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        });</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        s</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">add</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(p);</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        s</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">add</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(p1);</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        s</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">add</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(p2);</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        s</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">add</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(p3);</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        for</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Person</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> pe</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">s) {</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">            System</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">out</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">println</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(pe);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol><li>在定义变量的时候，实现java.lang包下的Compare接口，再实现compareTo方法</li></ol><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Person</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> implements</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Comparable</span><span style="--shiki-light:#C18401;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Person</span><span style="--shiki-light:#C18401;--shiki-dark:#ABB2BF;">&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">{</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> int</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> age</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">    Person</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;"> age</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">){</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        this</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">age</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">age;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    public</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> String</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> toString</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(){</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        return</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;年龄&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">+</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">age;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    @</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">Override</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> int</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> compareTo</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Person</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;"> o</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        return</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> this</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">age</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">-</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">o</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">age</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h1 id="map" tabindex="-1"><a class="header-anchor" href="#map"><span>Map</span></a></h1><h2 id="hashset和hashmap的区别" tabindex="-1"><a class="header-anchor" href="#hashset和hashmap的区别"><span>HashSet和HashMap的区别</span></a></h2><p>HashSet是Set接口的一种实现方式，它的内部实现还是HashMap，元素作为HashMap的键存储，所有的值都指向同一个特殊值，通常为null。HashSet 底层封装了 HashMap 的方法，体现了装饰器模式的思想。</p><h2 id="hashmap的扩容机制" tabindex="-1"><a class="header-anchor" href="#hashmap的扩容机制"><span>HashMap的扩容机制</span></a></h2><p>因为会出现hash冲突，如果数据太多，冲突会越来越严重，此时就需要扩容了。</p><p>在 HashMap 中有阈值的概念，阈值等于capacity*loadfactor，超过这个阈值就会触发扩容。</p><p>扩容的时候，默认会新建一个数组，新数组的大小是老数组的两倍。然后将 map 内的元素重新 hash 映射搬运到新的数组中。</p><p>在JDK 1.8后，数组的长度是2的次方，目扩容新数组的大小是老数组的两倍。因此只用看原来hash值最高位是否为是，如果是1说明需要移到新位置，且新位置的下标就是原下标+原数组大小，如果是0就还是在原位置。</p><h2 id="为什么-hashmap-的容量是-2-的幂呢" tabindex="-1"><a class="header-anchor" href="#为什么-hashmap-的容量是-2-的幂呢"><span>为什么 HashMap 的容量是 2 的幂呢？</span></a></h2><ol><li><strong>提高计算索引效率</strong>：当容量为2的幂时，可以通过 (n - 1) &amp; hash 来代替取模操作，位运算的效率比取模运算高得多当容量是 2 的幂时，快速计算索引位置</li><li><strong>减少哈希冲突</strong>：如果容量不是 2 的幂，进行与操作，某些低位的哈希值可能会被忽略，导致哈希冲突增加。</li><li><strong>简化扩容和再哈希</strong>：当 HashMap 扩容时，新容量也是 2 的幂，这使得旧容量到新容量的映射关系非常简单，只需要判断原哈希值的最高有效位是 0 还是 1 就可以确定新索引位置，这简化了再哈希的过程。</li></ol><h2 id="什么是哈希冲突-怎么解决哈希冲突" tabindex="-1"><a class="header-anchor" href="#什么是哈希冲突-怎么解决哈希冲突"><span>什么是哈希冲突，怎么解决哈希冲突？</span></a></h2><p>哈希冲突是不同的值经过哈希函数得到相同的hash值，因为哈希值相同，所以这些键会被映射到同一个槽中，也就是发生了哈希碰撞。</p><p>解决方法</p><ol><li>链地址法。将哈希表每个槽的位置变成一个链表，当多个键的哈希值相同时，将它们存储在同一个链表中</li><li>开放寻址法。如果出现碰撞，寻找哈希表中的下一个可用位置。比如有线性探测法、平方探测法</li><li>再哈希法。在出现碰撞时，使用第二个哈希函数计算新的索引位置</li></ol><h2 id="hashmap的底层数据结构" tabindex="-1"><a class="header-anchor" href="#hashmap的底层数据结构"><span>Hashmap的底层数据结构</span></a></h2><p>HashMap底层数据结构是数组+链表，JDK 8之后引入了红黑树。</p><p>数组内的元素包含了key和value，当put一个键值对时，会根据一个hash算法得出key的hash值，然后通过数组长度(n-1)&amp;hash得到数组下标，然后根据数组下标，插入键值对。</p><p>可能会发生哈希冲突。HashMap通过链表法来解决的，JDK1.8之前采用的是头插法，JDK1.8之后采用尾插法。</p><p>不过，链表过长时，查询效率会比较低，于是当链表的长度超过 8 时，且数组的长度大于 64，链表就会转换为红黑树。当红黑树节点小于6时，又会退化成链表。</p><h2 id="为什么链表转成红黑树-直接用红黑树不就得了" tabindex="-1"><a class="header-anchor" href="#为什么链表转成红黑树-直接用红黑树不就得了"><span>为什么链表转成红黑树，直接用红黑树不就得了？</span></a></h2><p>因为红黑树的节点大小是普通链表节点大小的两倍，为了节省内存空间不会直接用红黑树。</p><h2 id="为什么节点少于6要从红黑树变回链表" tabindex="-1"><a class="header-anchor" href="#为什么节点少于6要从红黑树变回链表"><span>为什么节点少于6要从红黑树变回链表</span></a></h2><p>为了平衡时间和空间，节点数量少链表遍历也很快，变回链表节约内存。</p><p>为什么少于6再变？</p><p>是为了留一个缓冲余地。假如发生碰撞，节点增减刚好在8附近，会发生链表和红黑树的不断转换，导致资源浪费。</p><h1 id="jdk1-8对hashmap有什么改动" tabindex="-1"><a class="header-anchor" href="#jdk1-8对hashmap有什么改动"><span>JDK1.8对HashMap有什么改动？</span></a></h1><ol><li>添加了红黑树机制</li><li>hash函数的优化，jdk1.8之后，将key的哈希码高16位和低16位进行异或，得到的 hash 值同时拥有高位和低位的特性，使得哈希码的分布更均匀，不容易冲突。</li><li>扩容和rehash的优化，1.8之后数组长度为2的次方，扩容倍数为2倍，这样在rehash的时候只用判断原来hash值最高位是否为1，不为1就不用移动位置，为1就移动到新数组的对应位置，原来的位置+原来数组长度</li><li>将头插法改成了尾插法，因为在扩容的时候容易逆序，逆序在多线程操作下可能会出现环，导致死循环。</li></ol><h1 id="你对红黑树了解多少-为什么不用二叉树-平衡树呢" tabindex="-1"><a class="header-anchor" href="#你对红黑树了解多少-为什么不用二叉树-平衡树呢"><span>你对红黑树了解多少？为什么不用二叉树/平衡树呢？</span></a></h1><p>红黑树本质上是一种二叉查找树，为了保持平衡，它又在二叉查找树的基础上增加了一些规则：</p><ol><li>每个节点要么是红色，要么是黑色；</li><li>根节点永远是黑色的；</li><li>所有的叶子节点都是是黑色的（注意这里说叶子节点其实是图中的 NULL 节点）；</li><li>每个红色节点的两个子节点一定都是黑色；</li><li>从任一节点到其子树中每个叶子节点的路径都包含相同数量的黑色节点；</li></ol><p>红黑树是一种相对平衡的二叉树，插入、删除、查找的最坏时间复杂度都为 O(logn)，避免了二叉树最坏情况下的O(n)时间复杂度。<strong>所以不用二叉搜索树。</strong></p><p>平衡二叉树是比红黑树更严格的平衡树，为了保持平衡，需要修改的次数更多，保持平衡的效率比较低。所以采用红黑树。</p><h1 id="hashmap和hashtable的区别" tabindex="-1"><a class="header-anchor" href="#hashmap和hashtable的区别"><span>HashMap和HashTable的区别</span></a></h1><ol><li>HashMap是非线程安全的，Hashtable的方法加了同步锁，是线程安全的</li><li>HashMap没有同步开销，所以性能会高一些</li><li>Hashmap允许一个null健和多个null值；HashTable都不允许</li><li>HashMap默认容量为16，使用Iterator遍历，支持fail-fast机制；HashTable默认容量为11.【fail-fast 机制当多个线程对同一个集合的内容进行操作时，就可能会产生fai-fast事件。例如:当某一个线程A通过iterator去遍历某集合的过程中，若该集合的内容被其他线程所改变了;那么线程A访问集合时，就会批出ConcurentModificationException异常，产生fail-fast事件。】</li></ol><h1 id="hashmap-是线程安全的吗-多线程下会有什么问题" tabindex="-1"><a class="header-anchor" href="#hashmap-是线程安全的吗-多线程下会有什么问题"><span>HashMap 是线程安全的吗？多线程下会有什么问题？</span></a></h1><p>HashMap不是线程安全的，可能会发生这些问题：</p><ol><li>如果线程A和B同时插入HashMap，线程A判断没有发生哈希冲突，切换B线程，判断没有发生哈希冲突；切换A线程，赋值成功，切换B线程赋值成功，B线程的值覆盖了A线程的值，发生了数据覆盖，用户感受到是数据丢失。</li></ol><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">if</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> ((p </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> tab[i </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> (n </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">-</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">) </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&amp;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> hash]) </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">==</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> null</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">)</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">        tab[i] </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> newNode</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(hash</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> key</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> value</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> null</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><ol><li>插入元素的时候需要将hashMap的size++，但size变量没有保证原子性，因此多线程下size自增是存在原子性问题。即添加了两个元素，但是size只增加了1。</li></ol><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">if</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> (</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">++</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">size </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> threshold)</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">        resize</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>多线程下扩容死循环。JDK1.7 中的 HashMap 使用头插法插入元素，在多线程的环境下，扩容的时候有可能导致环形链表的出现，形成死循环。因此，JDK1.8 使用尾插法插入元素，在扩容时会保持链表元素原本的顺序，不会出现环形链表的问题。</li><li>put 和 get 并发时，可能导致 get 为 null。线程 1 执行 put 时，因为元素个数超出 threshold 而导致 rehash，线程 2 此时执行 get，有可能导致这个问题。这个问题在 JDK 1.7 和 JDK 1.8 中都存在。</li></ul><h1 id="有什么办法能解决hashmap线程不安全的问题呢" tabindex="-1"><a class="header-anchor" href="#有什么办法能解决hashmap线程不安全的问题呢"><span>有什么办法能解决HashMap线程不安全的问题呢？</span></a></h1><p>Java 中有 HashTable、Collections.synchronizedMap、以及 ConcurrentHashMap 可以实现线程安全的 Map。</p><ol><li>HashTable 是直接在操作方法上加 synchronized 关键字，锁住整个table数组，粒度比较大；</li><li>Collections.synchronizedMap 是使用 Collections 集合工具的内部类，通过传入 Map 封装出一个 SynchronizedMap 对象，内部定义了一个对象锁，方法内通过对象锁实现；</li><li>ConcurrentHashMap 在jdk1.7中使用分段锁，在jdk1.8中使用CAS+synchronized。</li></ol><h1 id="说一下concurrenthashmap的实现" tabindex="-1"><a class="header-anchor" href="#说一下concurrenthashmap的实现"><span>说一下ConcurrentHashmap的实现</span></a></h1><p>ConcurrentHashmap在jdk1.7版本是基于分段锁实现，在jdk1.8是基于CAS+synchronized实现。</p><h3 id="jdk1-7版本-分段锁" tabindex="-1"><a class="header-anchor" href="#jdk1-7版本-分段锁"><span>jdk1.7版本 分段锁</span></a></h3><p>1.7版本的ConcurrentHashMap，引入了一个Segment数组，Segment继承了ReentrantLock，Segment则包含HashEntry的数组，实现线程安全原理就是先通过 key的 hash 判断得到 Segment数组的下标，将这个 Segment 上锁，然后再次通过 key的 hash 得到 Segment 里 HashEnty数组的下标，就和HashMap一致了。</p><figure><img src="https://cdn.nlark.com/yuque/0/2024/png/39067949/1719322039413-937c26d4-36e2-4404-8e4b-ae8b0ca38947.png" alt="https://cdn.nlark.com/yuque/0/2024/png/39067949/1719322039413-937c26d4-36e2-4404-8e4b-ae8b0ca38947.png" tabindex="0" loading="lazy"><figcaption>https://cdn.nlark.com/yuque/0/2024/png/39067949/1719322039413-937c26d4-36e2-4404-8e4b-ae8b0ca38947.png</figcaption></figure><p>实际上就是相当于每个Segment都是一个HashMap，默认的Segment数组长度是16，也就是支持16个线程的并发写，Segment之间相互不会受到影响。</p><p>jdk1.7的分段锁已经有了细化锁粒度的概念，但是它的缺陷是 Segment 数组一旦初始化了之后不会扩容，只有 HashEntny数组会扩容，这就导致并发度过于死板，不能随着数据的增加而提高并发度。</p><p><strong>put流程</strong></p><p>整个流程和HashMap非常类似，只不过是先定位到具体的Segment，然后通过ReentrantLock去操作而已。</p><ol><li>计算hash，定位到segment，segment如果是空就先初始化</li><li>使用ReentrantLock加锁，如果获取锁失败则尝试自旋，自旋超过次数就阻塞获取，保证一定获取锁成功</li><li>遍历HashEntry，就是和HashMap一样，数组中key和hash一样就直接替换，不存在就再插入链表，链表同样操作</li></ol><h3 id="jdk1-8版本-cas-synchronized" tabindex="-1"><a class="header-anchor" href="#jdk1-8版本-cas-synchronized"><span>jdk1.8版本 CAS+synchronized</span></a></h3><p>jdk1.8主要利用CAS机制和synchronized关键字。</p><p>实现思路也简单：当put一个值的时候</p><p><strong>put流程</strong></p><ol><li>首先计算hash，遍历node数组，如果node是空的话，就通过CAS+自旋的方式初始化</li><li>如果发现hash==MOVED，说明需要扩容，执行扩容【支持协程扩容，多线程扩容】</li><li>如果都不满足，就使用synchronized 将这个 node 上锁，写入数据，写入数据同样判断链表、红黑树，链表写入和HashMap的方式一样，key hash一样就覆盖，反之就尾插法，链表长度超过8就转换成红黑树</li></ol><figure><img src="https://cdn.nlark.com/yuque/0/2024/png/39067949/1719145462721-61e7012e-463b-4773-bcca-9bd61734f6a2.png" alt="https://cdn.nlark.com/yuque/0/2024/png/39067949/1719145462721-61e7012e-463b-4773-bcca-9bd61734f6a2.png" tabindex="0" loading="lazy"><figcaption>https://cdn.nlark.com/yuque/0/2024/png/39067949/1719145462721-61e7012e-463b-4773-bcca-9bd61734f6a2.png</figcaption></figure><h3 id="get方法需要加锁吗" tabindex="-1"><a class="header-anchor" href="#get方法需要加锁吗"><span>get方法需要加锁吗</span></a></h3><p>不需要加锁。保证 put 的时候线程安全之后，get 的时候只需要保证可见性，通过用 volatile 来修饰节点的 value 和 next 指针来实现的。</p><h1 id="concurrenthashmap为什么不支持key或value为null" tabindex="-1"><a class="header-anchor" href="#concurrenthashmap为什么不支持key或value为null"><span>ConcurrentHashMap为什么不支持key或value为null</span></a></h1><ol><li>简化代码实现，在并发环境下，可以避免对null的特殊处理，提高代码的可维护性。</li><li>value不为null，避免二义性。多线程环境下，get方法返回null时，无法区分map到底是不存在这个key，还是被put(key,null)了。因为调用get(key)返回null后，再调用containsKey()，两个方法之间可能有别的线程put了这个key。</li></ol><h1 id="hashmap-内部节点是有序的吗" tabindex="-1"><a class="header-anchor" href="#hashmap-内部节点是有序的吗"><span>HashMap 内部节点是有序的吗？</span></a></h1><p>HashMap是无序的，根据 hash 值随机插入。</p><p>如果想使用有序的Map，可以使用LinkedHashMap 或者 TreeMap。</p><h1 id="讲讲-linkedhashmap" tabindex="-1"><a class="header-anchor" href="#讲讲-linkedhashmap"><span>讲讲 LinkedHashMap</span></a></h1><p>LinkedHashMap的父类是HashMap，所以HashMap有的它都有，然后基于HashMap做了一些拓展。 LinkedHashMap的 Entry增加before和after两个指针用于标识前置节点和后置节点。从而实现节点的有序。</p><h1 id="讲讲-treemap" tabindex="-1"><a class="header-anchor" href="#讲讲-treemap"><span>讲讲 TreeMap</span></a></h1><p>TreeMap内部通过红黑树来实现。可以让 key所属的类实现 Comparable 接口，或者自定义实现一个Comparator，传给 TreeMap 用于 key 的比较。默认是按照自然顺序(键的Comporable实现)排序。</p><p>TreeMap不允许键为null，允许值为null。</p><h1 id="hashmap的put流程" tabindex="-1"><a class="header-anchor" href="#hashmap的put流程"><span>HashMap的put流程</span></a></h1><ol><li>首先通过hashcode()方法获得哈希值，再进行哈希值的扰动【用高16位和低16位进行异或操作，尽量哈希值的每一位都进行运算，减少哈希冲突】，获取一个新的哈希值。(key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);</li><li>根据哈希值计算下标，如果下表正好没有存放数据，直接插入即可；如果下标处有值且key相等则直接覆盖。tab[i = (n - 1) &amp; hash])</li><li>key不相等就是发生了哈希冲突，判断table[i]是否为树节点，是则向树中插入节点。不是向链表中插入数据，</li><li>如果链表中插入节点的时候，链表长度大于等于8，则需要把链表转换为红黑树。treeifyBin(tab, hash);</li><li>最后所有元素处理完成后，判断是否超过阈值；threshold【maxLength*0.75】，超过则扩容。</li></ol><h1 id="hashmap是怎么查找元素的" tabindex="-1"><a class="header-anchor" href="#hashmap是怎么查找元素的"><span>HashMap是怎么查找元素的？</span></a></h1><ol><li>使用hashcode()获得哈希值，再使用扰动函数，获取新的哈希值</li><li>通过哈希函数计算数组下标，获取节点</li><li>当前节点和key匹配，直接返回</li><li>否则，当前节点是否为树节点，查找红黑树</li><li>否则，遍历链表查找</li></ol><h1 id="怎么遍历hashmap" tabindex="-1"><a class="header-anchor" href="#怎么遍历hashmap"><span>怎么遍历HashMap</span></a></h1><ol><li>遍历entry</li><li>分别遍历key和value</li><li>通过iterator迭代器进行遍历</li><li>通过lambda表达式进行遍历</li></ol><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> TraverseHashMap</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> static</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> main</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">String</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[] </span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">args</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">        HashMap</span><span style="--shiki-light:#E45649;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Integer</span><span style="--shiki-light:#E45649;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Integer</span><span style="--shiki-light:#E45649;--shiki-dark:#ABB2BF;">&gt; </span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">map</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">new</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> HashMap</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;&gt;();</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        map</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">put</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        map</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">put</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">2</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        map</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">put</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">3</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">        //方式一：通过遍历entrySet</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        for</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Map</span><span style="--shiki-light:#E45649;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Entry</span><span style="--shiki-light:#E45649;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Integer</span><span style="--shiki-light:#E45649;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Integer</span><span style="--shiki-light:#E45649;--shiki-dark:#ABB2BF;">&gt; </span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">entry</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> :</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">map</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">entrySet</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()){</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">            System</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">out</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">println</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">entry</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">getKey</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">+</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">entry</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">getValue</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">());</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">        //方式二：分别遍历keySet和values</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        for</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Integer</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> key</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">map</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">keySet</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()){</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">            System</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">out</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">println</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(key);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        }</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        for</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Integer</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> value</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> map</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">values</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()){</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">            System</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">out</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">println</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(value);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        }</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">        //方式三：使用迭代器进行迭代</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">        Iterator</span><span style="--shiki-light:#E45649;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Map</span><span style="--shiki-light:#E45649;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Entry</span><span style="--shiki-light:#E45649;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Integer</span><span style="--shiki-light:#E45649;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Integer</span><span style="--shiki-light:#E45649;--shiki-dark:#ABB2BF;">&gt;&gt; </span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">entries</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">map</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">entrySet</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">().</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">iterator</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        while</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">entries</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">hasNext</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()){</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">            Map</span><span style="--shiki-light:#E45649;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Entry</span><span style="--shiki-light:#E45649;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Integer</span><span style="--shiki-light:#E45649;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Integer</span><span style="--shiki-light:#E45649;--shiki-dark:#ABB2BF;">&gt; </span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">next</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> entries</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">next</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">            System</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">out</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">println</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">next</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">getKey</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">+</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">next</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">getValue</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">());</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        }</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">        //方式四：通过lambda表达式进行遍历</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        map</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">forEach</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">((k,v)</span><span style="--shiki-light:#C18401;--shiki-dark:#C678DD;">-&gt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> System</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">out</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">println</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;key:&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">+</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">k</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">+</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;,value:&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">+</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">v));</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h1 id="concurrenthashmap-能保证复合操作的原子性吗" tabindex="-1"><a class="header-anchor" href="#concurrenthashmap-能保证复合操作的原子性吗"><span>ConcurrentHashMap 能保证复合操作的原子性吗？</span></a></h1><p><code>ConcurrentHashMap</code> 是线程安全的，意味着它可以保证多个线程同时对它进行读写操作时，不会出现数据不一致的情况，也不会导致 JDK1.7 及之前版本的 <code>HashMap</code> 多线程操作导致死循环问题。但是，这并不意味着它可以保证所有的复合操作都是原子性的，一定不要搞混了！</p><p>复合操作是指由多个基本操作(如<code>put</code>、<code>get</code>、<code>remove</code>、<code>containsKey</code>等)组成的操作，例如先判断某个键是否存在<code>containsKey(key)</code>，然后根据结果进行插入或更新<code>put(key, value)</code>。这种操作在执行过程中可能会被其他线程打断，导致结果不符合预期。</p><p>例如，有两个线程 A 和 B 同时对 <code>ConcurrentHashMap</code> 进行复合操作，如下：</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">// 线程 A</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">if</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> (</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">!</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">map</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">containsKey</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(key)</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">) {</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">map</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">put</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(key, value);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">}</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">// 线程 B</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">if</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> (</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">!</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">map</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">containsKey</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(key)</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">) {</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">map</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">put</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(key, anotherValue);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果线程 A 和 B 的执行顺序是这样：</p><ol><li>线程 A 判断 map 中不存在 key</li><li>线程 B 判断 map 中不存在 key</li><li>线程 B 将 (key, anotherValue) 插入 map</li><li>线程 A 将 (key, value) 插入 map</li></ol><p>那么最终的结果是 (key, value)，而不是预期的 (key, anotherValue)。这就是复合操作的非原子性导致的问题。</p><p><strong>那如何保证</strong> <code>ConcurrentHashMap</code> <strong>复合操作的原子性呢？</strong></p><p><code>ConcurrentHashMap</code> 提供了一些<strong>原子性的复合操作</strong>，如 <code>putIfAbsent</code>、<code>compute</code>、<code>computeIfAbsent</code> 、<code>computeIfPresent</code>、<code>merge</code>等。这些方法都可以接受一个函数作为参数，根据给定的 key 和 value 来计算一个新的 value，并且将其更新到 map 中。</p><p>上面的代码可以改写为：</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">// 线程 A</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">map</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">putIfAbsent</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(key, value);</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">// 线程 B</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">map</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">putIfAbsent</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(key, anotherValue);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>或者：</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">// 线程 A</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">map</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">computeIfAbsent</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(key, k </span><span style="--shiki-light:#C18401;--shiki-dark:#C678DD;">-&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> value);</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">// 线程 B</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">map</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">computeIfAbsent</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(key, k </span><span style="--shiki-light:#C18401;--shiki-dark:#C678DD;">-&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> anotherValue);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>很多同学可能会说了，这种情况也能加锁同步呀！确实可以，但不建议使用加锁的同步机制，违背了使用 <code>ConcurrentHashMap</code> 的初衷。在使用 <code>ConcurrentHashMap</code> 的时候，尽量使用这些原子性的复合操作方法来保证原子性。</p><h1 id="阻塞队列" tabindex="-1"><a class="header-anchor" href="#阻塞队列"><span>阻塞队列</span></a></h1><p>BlockingQueue——Queue下的子接口</p><h2 id="阻塞队列的特点" tabindex="-1"><a class="header-anchor" href="#阻塞队列的特点"><span>阻塞队列的特点</span></a></h2><p>阻塞队列是一种特殊的队列，它具有以下几个特点：</p><ol><li>阻塞特性：当队列为空时，从队列中获取元素的操作将会被阻塞，直到队列中有新的元素被添加；当队列已满时，向队列中添加元素的操作将会被阻塞，直到队列中有空的位置，这就是等待唤醒机制。</li><li>线程安全：阻塞队列内部通过同步机制来保证多线程环境下的数据一致性。</li><li>有界性：阻塞队列可以设置容量上限，当队列满时，后续的元素将无法添加。</li><li>公平性：阻塞队列可以选择公平或非公平的策略来决定线程的获取顺序。公平队列会按照线程的请求顺序进行处理（线程按先来后到顺序排队获取元素），而非公平队列则允许新的线程插队执行（线程竞争）。比如：SynchronousQueue。</li></ol><p>阻塞队列常用于解决生产者-消费者问题，它能够有效地衔接生产者和消费者之间的速度差异，提供一种协调和安全的数据交互方式。</p><h2 id="阻塞队列的核心方法" tabindex="-1"><a class="header-anchor" href="#阻塞队列的核心方法"><span>阻塞队列的核心方法</span></a></h2><ul><li>添加元素</li></ul><table><thead><tr><th>方法</th><th>描述</th><th>是否阻塞</th></tr></thead><tbody><tr><td>add方法</td><td>往队列尾部添加元素，内部调用offer方法</td><td>否</td></tr><tr><td>put方法</td><td>往队列尾部添加元素，如果队列已满，则阻塞等待</td><td>是</td></tr><tr><td>offer方法</td><td>往队列尾部添加元素，如果队列已满，则返回false，不会阻塞</td><td>否</td></tr></tbody></table><ul><li>获取元素</li></ul><table><thead><tr><th>方法</th><th>描述</th><th>是否阻塞</th></tr></thead><tbody><tr><td>take方法</td><td>take方法：移除并返回队列头部的元素，如果队列为空，则阻塞等待</td><td>是</td></tr><tr><td>poll方法</td><td>移除并返回队列头部的元素，如果队列为空，则返回null，不会阻塞</td><td>否</td></tr><tr><td>peek方法</td><td>返回队列头部的元素（不移除），如果队列为空，则返回null，不会阻塞</td><td>否</td></tr></tbody></table><h2 id="常见的阻塞队列" tabindex="-1"><a class="header-anchor" href="#常见的阻塞队列"><span>常见的阻塞队列</span></a></h2><ol><li>ArrayBlockingQueue：基于数组实现的有界阻塞队列，它的容量在创建时指定，并且不能动态扩展。</li><li>LinkedBlockingQueue：基于链表实现的有界阻塞队列，链表的长度可以通过构造函数显式指定，如果使用默认的构造函数，则默认大小是Integer.MAX_VALUE。</li><li>PriorityBlockingQueue：基于优先级堆排序实现的阻塞队列（可扩容），元素按照优先级顺序进行排序。</li><li>SynchronousQueue：不存储元素的阻塞队列，每个插入操作都必须等待一个相应的删除操作，反之亦然。</li></ol><h2 id="阻塞队列的原理" tabindex="-1"><a class="header-anchor" href="#阻塞队列的原理"><span>阻塞队列的原理</span></a></h2><p>常用的阻塞队列，比如：ArrayBlockingQueue、LinkedBlockingQueue、PriorityBlockingQueue底层都是采用ReentrantLock锁来实现线程的互斥，而ReentrantLock底层采用了AQS框架实现线程队列的同步，线程的阻塞是调用LockSupport.park实现，唤醒是调用LockSupport.unpark实现，具体可以看我之前的文章，SynchronousQueue底层虽然没有用AQS框架，但也用的是LockSupport实现线程的阻塞与唤醒。</p><p>阻塞队列的原理可以通过两个关键组件来解释：锁和条件变量。</p><ul><li>锁</li></ul><p>阻塞队列使用锁来保护共享资源，控制线程的互斥访问。在队列为空或已满时，线程需要等待相应的条件满足才能继续执行。</p><ul><li>条件变量Condition</li></ul><p>条件变量是锁的一个补充，在某些特定的条件下，线程会进入等待状态。当条件满足时，其他线程会通过调用条件变量的唤醒方法（比如signal()或signalAll()）来通知等待的线程进行下一步操作。</p><p>当一个线程从队列中获取元素时，它会使用lockInterruptibly()获取队列的锁，这个方法优先考虑中断。然后检查队列是否为空。如果不为空，就取出元素并返回；如果为空，这个线程将notEmpty.await()进入等待状态，直到其他线程向队列中插入元素并通过条件变量NotEmpty唤醒它。当一个线程试图向已满的阻塞队列插入元素时，它会获取队列的锁，并检查队列是否已满。如果已满，这个线程将进入等待状态，直到其他线程从队列中获取元素并通过条件变量NotFull唤醒它。</p><h2 id="同步队列的使用场景" tabindex="-1"><a class="header-anchor" href="#同步队列的使用场景"><span>同步队列的使用场景</span></a></h2><ol><li>生产者-消费者模型：阻塞队列能够很好地平衡生产者和消费者之间的速度差异，既能保护消费者不会消费到空数据，也能保护生产者不会造成队列溢出，能够有效地解耦生产者和消费者，提高系统的稳定性和吞吐量。</li><li>线程池：在线程池中，阻塞队列可以作为任务缓冲区，将待执行的任务放入队列中，由线程池中的工作线程按照一定的策略进行执行。</li><li>同步工具：阻塞队列还可以作为一种同步工具，在多线程环境下实现线程之间的协作。</li><li>数据缓冲：阻塞队列可以用作数据缓冲区，当生产者的速度大于消费者的速度时，数据可以先存储在队列中，等待消费者处理</li><li>事件驱动编程：阻塞队列可以用于事件驱动的编程模型，当事件发生时，将事件对象放入队列中，由消费者进行处理</li></ol></div><!----><footer class="vp-page-meta"><div class="vp-meta-item edit-link"><a class="auto-link external-link vp-meta-label" href="https://github.com/Cutewr/edit/main/src/posts/Java/JavaCollection.md" aria-label="在 GitHub 上编辑此页" rel="noopener noreferrer" target="_blank"><!--[--><svg xmlns="http://www.w3.org/2000/svg" class="icon edit-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="edit icon" name="edit"><path d="M430.818 653.65a60.46 60.46 0 0 1-50.96-93.281l71.69-114.012 7.773-10.365L816.038 80.138A60.46 60.46 0 0 1 859.225 62a60.46 60.46 0 0 1 43.186 18.138l43.186 43.186a60.46 60.46 0 0 1 0 86.373L588.879 565.55l-8.637 8.637-117.466 68.234a60.46 60.46 0 0 1-31.958 11.229z"></path><path d="M728.802 962H252.891A190.883 190.883 0 0 1 62.008 771.98V296.934a190.883 190.883 0 0 1 190.883-192.61h267.754a60.46 60.46 0 0 1 0 120.92H252.891a69.962 69.962 0 0 0-69.098 69.099V771.98a69.962 69.962 0 0 0 69.098 69.098h475.911A69.962 69.962 0 0 0 797.9 771.98V503.363a60.46 60.46 0 1 1 120.922 0V771.98A190.883 190.883 0 0 1 728.802 962z"></path></svg><!--]-->在 GitHub 上编辑此页<!----></a></div><div class="vp-meta-item git-info"><div class="update-time"><span class="vp-meta-label">上次编辑于: </span><!----></div><div class="contributors"><span class="vp-meta-label">贡献者: </span><!--[--><!--[--><span class="vp-meta-info" title="email: 2574303446@qq.com">Cutewr</span><!--]--><!--]--></div></div></footer><nav class="vp-page-nav"><a class="route-link auto-link prev" href="/posts/Java/JavaBasic.html" aria-label="Java基础"><div class="hint"><span class="arrow start"></span>上一页</div><div class="link"><span class="font-icon icon fa-fw fa-sm fas fa-pen-to-square" style=""></span>Java基础</div></a><a class="route-link auto-link next" href="/posts/Java/JUC.html" aria-label="JUC并发编程"><div class="hint">下一页<span class="arrow end"></span></div><div class="link">JUC并发编程<span class="font-icon icon fa-fw fa-sm fas fa-pen-to-square" style=""></span></div></a></nav><!----><!----><!--]--></main><!--]--><footer class="vp-footer-wrapper"><div class="vp-footer">默认页脚</div><div class="vp-copyright">Copyright © 2024 Cutewr </div></footer></div><!--]--><!--[--><!----><!--]--><!--]--></div>
    <script src="/assets/js/runtime~app.0200d20d.js" defer></script><script src="/assets/js/4438.c841338e.js" defer></script><script src="/assets/js/app.fa5d547b.js" defer></script>
  </body>
</html>
