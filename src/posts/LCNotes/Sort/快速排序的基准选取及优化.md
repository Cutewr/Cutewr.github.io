---
date: 2024-08-29
category:
  - 排序算法
tag:
  - 快速排序
---

# 快速排序的索引选取及优化
## 快速排序的基本原理
关于快速排序，它的基本思想就是选取一个基准，一趟排序确定两个区间，一个区间全部比基准值小，另一个区间全部比基准值大，接着再选取一个基准值来进行排序，以此类推，最后得到一个有序的数列。

### 快速排序的基本思路

1. 选取基准值，通过不同的方式挑选出基准值。
2. 用分治的思想进行分割，通过该基准值在序列中的位置，将序列分成两个区间，在准值左边的区间里的数都比基准值小（默认以升序排序），在基准值右边的区间里的数都比基准值大。
3. 递归调用快速排序的函数对两个区间再进行上两步操作，直到调用的区间为空或是只有一个数。

## 举例说明

### 第一轮

假设我们现在对“6 1 2 7 9 3 4 5 10 8”这个 10 个数进行排序。首先在这个序列中随便找一个数作为基准数（就是一个用来参照的数）。为了方便，就让第一个数 6 作为基准数吧。接下来，需要将这个序列中所有比基准数大的数放在 6 的右边，比基准数小的数放在 6 的左边，得到下面这种排列。

```text
3 1 2 5 4 6 9 7 10 8
```

方法其实很简单：

1. 分别从初始序列“6 1 2 7 9 3 4 5 10 8”两端开始“探测”。
2. 先从右往左找一个小于 6 的数，再从左往右找一个大于 6 的数，然后交换他们。

![](https://cdn.jsdelivr.net/gh/Cutewr/blogimage@main/img/522430fad3243b486816f4daf3cbf101.png)

这里可以用两个变量 i 和 j，分别指向序列最左边和最右边。我们为这两个变量起个好听的名字“哨兵 i”和“哨兵 j”。刚开始的时候让哨兵 i 指向序列的最左边（即 i=1），指向数字 6。让哨兵 j 指向序列的最右边（即 j=10），指向数字 8。

<img src="https://cdn.jsdelivr.net/gh/Cutewr/blogimage@main/img/QQ_1724930428617.png" style="zoom:50%; display: block; margin: auto;" />

首先哨兵 j 开始出动。因为此处设置的基准数是最左边的数，所以需要让哨兵 j 先出动，这一点非常重要（请自己想一想为什么）。哨兵 j 一步一步地向左挪动（即 j--），直到找到一个小于 6 的数停下来。接下来哨兵 i 再一步一步向右挪动（即 i++），直到找到一个数大于 6 的数停下来。最后哨兵 j 停在了数字 5 面前，哨兵 i 停在了数字 7 面前。

第二次交换结束，“探测”继续。哨兵 j 继续向左挪动，他发现了 3（比基准数 6 要小，满足要求）之后又停了下来。哨兵 i 继续向右移动，糟啦！此时哨兵 i 和哨兵 j 相遇了，哨兵 i 和哨兵 j 都走到 3 面前。说明此时“探测”结束。我们将基准数 6 和 3 进行交换。交换之后的序列如下。

```text
3 1 2 5 4 6 9 7 10 8
```

<img src="https://cdn.jsdelivr.net/gh/Cutewr/blogimage@main/img/0c4a0f470f79aeadc6b647f336d83a98.png" style="zoom:67%; display: block; margin: auto;" />

到此第一轮“探测”真正结束。此时以基准数 6 为分界点，6 左边的数都小于等于 6，6 右边的数都大于等于 6。

回顾一下刚才的过程，其实哨兵 j 的使命就是要「找小于基准数的数」，而哨兵 i 的使命就是要找「大于基准数的数」，直到 i 和 j 碰头为止。

OK，解释完毕。现在基准数 6 已经归位，它正好处在序列的第 6 位。此时我们已经将原来的序列，以 6 为分界点拆分成了两个序列，左边的序列是“3 1 2 5 4”，右边的序列是“ 9 7 10 8 ”。接下来还需要分别处理这两个序列。因为 6 左边和右边的序列目前都还是很混乱的。不过不要紧，我们已经掌握了方法，接下来只要模拟刚才的方法分别处理 6 左边和右边的序列即可。现在先来处理 6 左边的序列吧。

### 第二轮

左边的序列是“3 1 2 5 4”。请将这个序列以 3 为基准数进行调整，使得 3 左边的数都小于等于 3，3 右边的数都大于等于 3。好了开始动笔吧。

调整完毕之后的序列的顺序应该是。

```text
2 1 3 5 4
```

OK，现在 3 已经归位。接下来需要处理 3 左边的序列“ 2 1 ”和右边的序列“5 4”。对序列“ 2 1 ”以 2 为基准数进行调整，处理完毕之后的序列为“1 2”，到此 2 已经归位。序列“1”只有一个数，也不需要进行任何处理。至此我们对序列“ 2 1 ”已全部处理完毕，得到序列是“1 2”。序列“5 4”的处理也仿照此方法，最后得到的序列如下。

```text
1 2 3 4 5 6 9 7 10 8
```

对于序列“9 7 10 8”也模拟刚才的过程，直到不可拆分出新的子序列为止。最终将会得到这样的序列，如下。

```text
1 2 3 4 5 6 7 8 9 10
```

### 总结
快速排序的每一轮处理其实就是将这一轮的基准数归位，直到所有的数都归位为止，排序就结束了。

快速排序之所比较快，因为相比冒泡排序，每次交换是跳跃式的。每次排序的时候设置一个基准点，将小于等于基准点的数全部放到基准点的左边，将大于等于基准点的数全部放到基准点的右边。这样在每次交换的时候就不会像冒泡排序一样每次只能在相邻的数之间进行交换。

交换的距离大，因此总的比较和交换次数就少了，速度自然就提高了。

当然在最坏的情况下『数组中重复元素很多』或者『数组基本有序』，仍可能是相邻的两个数进行了交换。因此快速排序的最差时间复杂度和冒泡排序是一样的都是 O(n^2^)，它的平均时间复杂度为 O(nlogn)。

## 代码演示
```java
package Sort;

public class QuickSort {
    public static void main(String[] args) {
        int []nums=new int[]{4,5,3,6,2,5,1};
        quickSort(nums,0,nums.length-1);
    }

    public static void quickSort(int []nums,int left,int right){
        if (left<right){
            int pivot=findPivot(nums,left,right);
            quickSort(nums,left,pivot-1);
            quickSort(nums,pivot+1,right);
        }
    }

    private static int findPivot(int[] nums, int left, int right) {
        int pivotValue=nums[left];	//选取基准元素
        while (left<right){
            while (left<right && nums[right]>=pivotValue){
                right--;	//移动右哨兵
            }
            nums[left]=nums[right];

            while (left<right && nums[left]<=pivotValue){
                left++;	 //移动左哨兵
            }
            nums[right]=nums[left];
        }
        nums[left]=pivotValue;
        for (int num : nums) {
            System.out.print(num + " ");
        }
        System.out.println();
        return left;
    }
}

```

## 关于快排的基准值的选取
### 固定位置选取基准值
基本思想：选取第一个或最后一个元素作为基准值。

```java
int SelectPivot(int arr[],int low,int high)  
{  
    return arr[low];//选择选取序列的第一个元素作为基准  
} 
```


注意：基本的快速排序选取第一个或最后一个元素作为基准。但是，这是一个很不好的处理方法。

如果输入序列是随机的，处理时间可以接受的。如果数组已经有序时，此时的分割就是一个非常不好的分割。因为每次划分只能使待排序序列减一，此时为最坏情况，快速排序沦为冒泡排序，时间复杂度为Θ(n^2^)。

而且，输入的数据是有序或部分有序的情况是相当常见的。因此，使用第一个元素作为枢纽元是非常糟糕的，为了避免这个情况，就引入了下面两个获取基准的方法。

### 随机选取基准值

基本思想：选取待排序列中任意一个数作为基准值。
引入的原因：在待排序列是部分有序时，固定选取基准使快排效率底下，要缓解这种情况，就引入了随机选取基准。

```java
int SelectPivot(int arr[],int low,int high)  
{  
  	Random rand=new Random();
    return arr[rand.nextInt(arr.length)];		//随机选取一个元素作为基准  
} 
```

这是一种相对安全的策略。由于枢轴的位置是随机的，那么产生的分割也不会总是会出现劣质的分割。在整个数组数字全相等时，仍然是最坏情况，时间复杂度是O(n^2^）。所以随机化快速排序可以对于绝大多数输入数据达到O(nlogn）的期望时间复杂度。

### 三数取中法，选取基准元

基本思想：取第一个数，最后一个数，第（N/2）个数即中间数，三个数中数值中间的那个数作为基准值。

举个例子，对于int a[] = { 2,5,4,9,3,6,8,7,1,0};，2、3、0，分别是第一个数，中间的数以及最后一个数，再选取这三个数中数值中间的数2为基准值。

引入的原因：虽然随机选取枢轴时，减少出现不好分割的几率，但是还是最坏情况下还是O(n^2^），要缓解这种情况，就引入了三数取中选取枢轴

分析：最佳的划分是将待排序的序列分成等长的子序列，使用序列的中间的值，也就是第N/2个数。可是，这很难算出来，并且会明显减慢快速排序的速度。这样的中值的估计可以通过随机选取三个元素并用它们的中值作为枢纽元而得到。因此一般的做法是使用左端、右端和中心位置上的三个元素的中值作为枢纽元。显然使用三数中值分割法消除了预排序输入的不好情形。  

```java
/*函数作用：取待排序序列中low、mid、high三个位置上数据，选取他们中间的那个数据作为枢轴*/  
int SelectPivotMedianOfThree(int arr[],int low,int high)  
{  
    int mid = low + ((high - low) >> 1);//计算数组中间的元素的下标  
  //使用三数取中法选择枢轴  
  if (arr[mid] > arr[high])//目标: arr[mid] <= arr[high]  
  {  
      swap(arr[mid],arr[high]);  
  }  
  if (arr[low] > arr[high])//目标: arr[low] <= arr[high]  
  {  
      swap(arr[low],arr[high]);  
  }  
  if (arr[mid] > arr[low]) //目标: arr[low] >= arr[mid]  
  {  
      swap(arr[mid],arr[low]);  
  }  
  //此时，arr[mid] <= arr[low] <= arr[high]  
  return arr[low];  
  //low的位置上保存这三个位置中间的值  
  //分割时可以直接使用low位置的元素作为枢轴，而不用改变分割函数了
}
```
测试数据分析：使用三数取中选择枢轴优势还是很明显的，但是还是处理不了重复数组。

## 优化方式

### 优化1：当待排序序列的长度分割到一定大小后，使用插入排序

原因：对于很小和部分有序的数组，快排不如插排好。当待排序序列的长度分割到一定大小后，继续分割的效率比插入排序要差，此时可以使用插排而不是快排

截止范围：待排序序列长度N = 10，虽然在5~20之间任一截止范围都有可能产生类似的结果，这种做法也避免了一些有害的退化情形。

```java 
if (high - low + 1 < 10)  
{  
    InsertSort(arr,low,high);  
    return;  
}//else时，正常执行快排
```

针对随机数组，使用三数取中选择枢轴+插排，效率还是可以提高一点，真是针对已排序的数组，是没有任何用处的。因为待排序序列是已经有序的，那么每次划分只能使待排序序列减一。此时，插排是发挥不了作用的。所以这里看不到时间的减少。另外，三数取中选择枢轴+插排还是不能处理重复数组

### 优化2：在一次分割结束后，可以把与Key相等的元素聚在一起，继续下次分割时，不用再对与key相等元素分割。
待排序序列

```text
6 4 6 7 1 6 7 6 8 6
```

三数取中选取枢轴：下标为4的数6

1. 第一步，在划分过程中，把与key相等元素放入数组的两端，结果为

```text
6 4 1 6(枢轴) 7 8 7 6 6 6
```

此时，与6相等的元素全放入在两端了。

2. 第二步，划分结束后，把与key相等的元素移到枢轴周围，结果为：

```text
1 4 6 6(枢轴) 6 6 6 7 8 7
```

此时，与6相等的元素全移到枢轴周围了

之后，在1 4 和 7 8 7两个子序列进行快排

```java
void QSort(int arr[],int low,int high)  
{  
    int first = low;  
    int last = high;  

    int left = low;  
    int right = high;  

    int leftLen = 0;  
    int rightLen = 0;  

    if (high - low + 1 < 10)  
    {  
        InsertSort(arr,low,high);  
        return;  
    }  

    //一次分割  
    int key = SelectPivotMedianOfThree(arr,low,high);//使用三数取中法选择枢轴  

    while(low < high)  
    {  
        while(high > low && arr[high] >= key)  
        {  
            if (arr[high] == key)//处理相等元素  
            {  
                swap(arr[right],arr[high]);  
                right--;  
                rightLen++;  
            }  
            high--;  
        }  
        arr[low] = arr[high];  
        while(high > low && arr[low] <= key)  
        {  
            if (arr[low] == key)  
            {  
                swap(arr[left],arr[low]);  
                left++;  
                leftLen++;  
            }  
            low++;  
        }  
        arr[high] = arr[low];  
    }  
    arr[low] = key;  

    //一次快排结束  
    //把与枢轴key相同的元素移到枢轴最终位置周围  
    int i = low - 1;  
    int j = first;  
    while(j < left && arr[i] != key)  
    {  
        swap(arr[i],arr[j]);  
        i--;  
        j++;  
    }  
    i = low + 1;  
    j = last;  
    while(j > right && arr[i] != key)  
    {  
        swap(arr[i],arr[j]);  
        i++;  
        j--;  
    }  
    QSort(arr,first,low - 1 - leftLen);  
    QSort(arr,low + 1 + rightLen,last);  
}  

```

三数取中选择枢轴+插排+聚集相等元素的组合，效果竟然好的出奇。

原因：在数组中，如果有相等的元素，那么就可以减少不少冗余的划分。这点在重复数组中体现特别明显啊。
其实这里，插排的作用还是不怎么大的。


概括：这里效率最好的快排组合 是：三数取中+插排+聚集相等元素,它和STL中的Sort函数效率差不多