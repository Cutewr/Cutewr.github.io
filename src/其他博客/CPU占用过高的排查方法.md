---
date: 2024-09-07
category:
  - 问题排查
---

# CPU占用过高，怎么排查？
## **出现问题的原因**

一种是由计算导致的CPU使用过高，一种是由内存不足，频繁垃圾回收导致的CPU使用过高。

1. 线程太多，上下文不停切换，比如大量线程激烈的锁竞争，线程不停阻塞恢复阻塞。或者产生死锁
2. 项目出现死循环，比如hashmap并发场景下的死循环
3. 频繁发生FULL GC

## **排查步骤**

1. 执行 top 命令，在linux系统上显示系统各个进程的资源占用状态，找到占用率很高的进程ID 1024

2. 执行 top -p 1024 -H 命令，查看当前进程下的所有线程信息，找到占用率很高的线程ID 2048，将ID转换成16进制得到800

3. 执行 jstack 1024> thread_stack.log 将进程的堆栈信息写入到文件中

4. 在thread_stack.log根据找到800对应的堆栈信息，根据堆栈信息定位到代码位置

5. 如果线程为GC线程（VM Thread），使用 jmap -histo> jmap.log 输出java堆中对象的统计信息，可能不停创建大对象，导致频繁GC导致CPU占用很高。或者使用jmap导出dump日志，使用mat工具查看，如果内存使用率不高，但FULL GC频繁，可能是手动调用System.gc()导致的。

## **特殊情况**

1. 不定期出现的接口耗时现象

接口偶尔会出现响应很慢的情况，思路是通过压测工具不断加大访问力度，那么大多数线程最终会阻塞在问题点，通过这些线程的堆栈信息，找到对应位置

2. 死锁

jsatck会自动检测出死锁

## **小结**

- **高CPU占用排查步骤**
1. TOP命令找到CPU使用率最高的进程和其线程信息，将线程id转化成16进制
2. jsatck 进程 打印进程的堆栈信息，根据线程id找到问题线程和它的堆栈信息，分析处理
- **高内存占用排查步骤**
1. TOP命令找到占用内存最高的进程
2. jmap -histo 进程ID 输出进程内对象统计信息，找出问题对象，代码中定位到对象创建位置
3. 或者jmap导出dump日志，使用mat工具查看
- **堆外内存泄漏排查**

使用gdb、strace等工具