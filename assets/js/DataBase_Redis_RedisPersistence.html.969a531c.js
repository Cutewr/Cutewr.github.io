"use strict";(self.webpackChunkvuepress_theme_hope_template=self.webpackChunkvuepress_theme_hope_template||[]).push([[8962],{6262:(e,i)=>{i.A=(e,i)=>{const s=e.__vccOpts||e;for(const[e,t]of i)s[e]=t;return s}},5167:(e,i,s)=>{s.r(i),s.d(i,{comp:()=>n,data:()=>r});var t=s(641);const a=[(0,t.Fv)('<h1 id="redis持久化" tabindex="-1"><a class="header-anchor" href="#redis持久化"><span>Redis持久化</span></a></h1><h2 id="redis-如何实现数据不丢失" tabindex="-1"><a class="header-anchor" href="#redis-如何实现数据不丢失"><span>Redis 如何实现数据不丢失？</span></a></h2><p>Redis 的读写操作都是在内存中，所以 Redis 性能才会高。但是当 Redis宕机或者重启后，内存中的数据就会丢失，那Redis 实现了数据持久化的机制，把数据存储到磁盘，这样Redis重启后就能够从磁盘中恢复原有的数据。</p><p>Redis 共有三种数据持久化的方式：</p><ul><li><strong>AOF 日志</strong>：每执行一条写操作命令，就把该命令以追加的方式写入到一个文件里；</li><li><strong>RDB 快照</strong>：将某一时刻的内存数据，以二进制的方式写入磁盘；</li><li><strong>混合持久化方式</strong>：Redis 4.0 新增的方式，集成了 AOF 和 RBD 的优点；</li></ul><h2 id="aof-日志" tabindex="-1"><a class="header-anchor" href="#aof-日志"><span>AOF 日志</span></a></h2><h3 id="简介" tabindex="-1"><a class="header-anchor" href="#简介"><span>简介</span></a></h3><p>Redis 在执行完一条写操作命令后，就会把该命令以追加的方式写入到磁盘文件里，然后 Redis重启时，会读取该文件记录的命令，然后逐一执行命令的方式来进行数据恢复。</p><blockquote><p>为什么先执行命令，再把数据写入日志呢？</p></blockquote><p>Reids 是先执行写操作命令后，才将该命令记录到 AOF 日志里的，这么做其实有两个好处。</p><ul><li><strong>避免额外的检查开销</strong>：因为如果先将写操作命令记录到 AOF 日志里，再执行该命令的话，如果当前的命令语法有问题，那么如果不进行命令语法检查，该错误的命令记录到 AOF 日志里后，Redis 在使用日志恢复数据时，就可能会出错。</li><li><strong>不会阻塞当前写操作命令的执行</strong>：因为当写操作命令执行成功后，才会将命令记录到 AOF 日志。</li></ul><p>当然，这样做也会带来风险：</p><ul><li><strong>数据可能会丢失：</strong> 执行写操作命令和记录日志是两个过程，那当 Redis 在还没来得及将命令写入到硬盘时，服务器发生宕机了，这个数据就会有丢失的风险。</li><li><strong>可能阻塞其他操作：</strong> 因为写AOF日志也是在主线程中执行，如果在将日志内容写入到硬盘时，服务器的硬盘的 I/O 压力太大，就会导致写硬盘的速度很慢，进而阻塞住了，也就会导致后续的命令无法执行。所以可能会给下一个命令带来阻塞风险。</li></ul><p>认真分析一下，其实这两个风险都有一个共性，都跟「 AOF 日志写回硬盘的时机」有关。</p><h3 id="aof写回策略" tabindex="-1"><a class="header-anchor" href="#aof写回策略"><span>AOF写回策略</span></a></h3><blockquote><p>AOF 写回策略有几种？</p></blockquote><p>Redis写入 AOF日志的过程，</p><ol><li>Redis 执行完写操作命令后，会将命令追加到内存中的server.aof_buf 缓冲区；</li><li>然后通过write()系统调用，先将aof_buf 缓冲区的数据拷贝到内核缓冲区 page cache，等待内核将数据写入硬盘；</li></ol><p>Redis 提供了3种写回硬盘的策略，控制的就是内核缓冲区的数据具体什么时候写入到硬盘。</p><p>在 Redis.conf 配置文件中的 appendfsync 配置项可以有以下 3 种参数可填：</p><ul><li><strong>Always</strong>，每次写命令执行完后，将AOF日志数据写回硬盘；这种就是可靠性高、最大程度保证数据不丢失；缺点就是每次写命令都要写回硬盘，性能开销大。</li><li><strong>Everysec</strong>，每次写命令执行完后，先将命令写入到 AOF 文件的内核缓冲区，然后每隔一秒将缓冲区里的内容写回到硬盘；这种方式性能适中，宕机时会丢失1秒内的数据</li><li><strong>No</strong>，意味着不由 Redis 控制写回硬盘的时机，转交给操作系统控制。性能好，但是宕机时会丢失很多数据，</li></ul><p>因此可以根据业务场景进行选择：</p><ul><li>如果要高性能，就选择 No 策略；</li><li>如果要高可靠，就选择 Always 策略；</li><li>如果允许数据丢失一点，但又想性能高，就选择 Everysec 策略。</li></ul><blockquote><p>这三种策略是怎么实现的？</p></blockquote><p>这三种策略是在控制 <code>fsync()</code> 函数的调用时机。调用 <code>fsync()</code> 函数，这样内核就会将内核缓冲区的数据写入到硬盘，等到硬盘写入完成后，该函数才会返回。</p><ul><li>Always 策略就是每次写入AOF文件数据进内核缓存区后，就执行 fsync() 函数；</li><li>Everysec 策略就会创建一个异步任务来执行 fsync() 函数；</li><li>No 策略就是永不执行 fsync() 函数;</li></ul><h3 id="aof-重写机制" tabindex="-1"><a class="header-anchor" href="#aof-重写机制"><span>AOF 重写机制</span></a></h3><blockquote><p>AOF 日志过大，会触发什么机制？</p></blockquote><p>随着执行的写操作命令越来越多，AOF日志文件的大小会越来越大。 当 AOF 日志文件过大就会带来性能问题，比如重启 Redis 后，需要读 AOF 文件的内容以恢复数据，如果文件过大，整个恢复的过程就会很慢。</p><p>所以，Redis提供了 <strong>AOF 重写机制</strong>，当 AOF 文件的大小超过所设定的阈值后，Redis 就会启用这个机制，来压缩 AOF 文件。</p><p>AOF重写机制，在重写时，读取当前数据库中最新的所有键值对，然后将每一个键值对用一条命令记录到「新的 AOF 文件」，等到全部记录完后，就将新的 AOF 文件替换掉现有的AOF文件。所以，重写机制的优点在于，假如某个键值对被多条写命令反复修改，最终也只需要根据这个「键值对」当前的最新状态记录。</p><p>举个例子，在没有使用重写机制前，假设前后执行了「<em>set name xiaolin</em>」和「<em>set name xiaolincoding</em>」这两个命令的话，就会将这两个命令记录到 AOF 文件。</p><figure><img src="https://cdn.jsdelivr.net/gh/Cutewr/blogimage@main/img/image-20240830205701133.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>但是<strong>在使用重写机制后，就会读取 name 最新的 value（键值对） ，然后用一条 「set name xiaolincoding」命令记录到新的 AOF 文件</strong>，之前的第一个命令就没有必要记录了，因为它属于「历史」命令，没有作用了。这样一来，一个键值对在重写日志中只用一条命令就行了。</p><p>这里说一下为什么重写 AOF 的时候，不直接复用现有的 AOF 文件，而是先写到新的 AOF 文件再覆盖过去。</p><p>因为如果 AOF 重写过程中失败了，现有的 AOF 文件就会造成污染，可能无法用于恢复使用。</p><p>所以 AOF 重写过程，先重写到新的 AOF 文件，重写失败的话，就直接删除这个文件就好，不会对现有的 AOF 文件造成影响。</p><blockquote><p>重写 AOF 日志的过程是怎样的？</p></blockquote><p>AOF后台重写，Redis 的<strong>重写 AOF 过程是由后台子进程 *bgrewriteaof* 来完成的</strong>，这么做可以达到两个好处：</p><ul><li>子进程进行 AOF 重写期间，主进程可以继续处理命令请求，从而避免阻塞主进程；</li><li>子进程带有主进程的数据副本，这里使用子进程而不是线程，因为如果是使用线程，多线程之间会共享内存，那么在修改共享内存数据的时候，需要通过加锁来保证数据的安全，而这样就会降低性能。而使用子进程，创建子进程时，父子进程是以只读的方式共享内存数据的，而当父子进程任意一方修改了该共享内存，就会发生「写时复制」，复制主进程修改的物理内存数据，于是父子进程就有了独立的数据副本，就不用加锁来保证数据安全，从而提升性能。</li></ul><p>触发重写机制后，主进程就会创建重写 AOF 的子进程，此时父子进程共享物理内存，重写子进程只会对这个内存进行只读，重写 AOF 子进程会读取数据库里的所有数据，并逐一把内存数据的键值对转换成一条命令，再将命令记录到重写日志（新的 AOF 文件）。</p><blockquote><p>重写时，主进程修改了key-value，发生写时复制，子进程和父进程数据不一致怎么办？</p></blockquote><p>为了解决这种数据不一致问题，Redis 设置了一个 <strong>AOF 重写缓冲区</strong>，这个缓冲区在创建 bgrewriteaof 子进程之后开始使用。在重写 AOF 期间，当 Redis 执行完一个写命令之后，它会<strong>同时将这个写命令写入到 「AOF 缓冲区」和 「AOF 重写缓冲区」</strong>。</p><img src="https://cdn.jsdelivr.net/gh/Cutewr/blogimage@main/img/image-20240830205738411.png" style="zoom:50%;display:block;margin:auto;"><p>也就是说，在 bgrewriteaof 子进程执行 AOF 重写期间，主进程需要执行以下三个工作:</p><ul><li>执行客户端发来的命令；</li><li>将执行后的写命令追加到 「AOF 缓冲区」；</li><li>将执行后的写命令追加到 「AOF 重写缓冲区」；</li></ul><p>当子进程完成 AOF 重写工作（<em>扫描数据库中所有数据，逐一把内存数据的键值对转换成一条命令，再将命令记录到重写日志</em>）后，会向主进程发送一条信号，信号是进程间通讯的一种方式，且是异步的。</p><p>主进程收到该信号后，会调用一个信号处理函数，该函数主要做以下工作：</p><ul><li>将 AOF 重写缓冲区中的所有内容追加到新的 AOF 的文件中，使得新旧两个 AOF 文件所保存的数据库状态一致；</li><li>新的 AOF 的文件进行改名，覆盖现有的 AOF 文件。</li></ul><p>信号函数执行完后，主进程就可以继续像往常一样处理命令了。</p><h2 id="rdb-快照方式" tabindex="-1"><a class="header-anchor" href="#rdb-快照方式"><span>RDB 快照方式</span></a></h2><h3 id="简介-1" tabindex="-1"><a class="header-anchor" href="#简介-1"><span>简介</span></a></h3><p>RDB 快照就是记录某一个时刻的内存实际数据。RDB 恢复数据的效率会比 AOF 高，因为直接将RDB文件读入内存就可以，不需要像 AOF 那样还要执行操作命令。</p><h3 id="怎么生成rdb文件" tabindex="-1"><a class="header-anchor" href="#怎么生成rdb文件"><span>怎么生成RDB文件</span></a></h3><ol><li>save和bgsave命令</li></ol><p>Redis 提供了两个命令来生成 RDB 文件，分别是 save 和 bgsave，他们的区别就在于是否在「主线程」里执行：</p><ul><li>save 命令，就会在主线程生成 RDB 文件，所以如果写入RDB文件的时间太长，<strong>会阻塞主线程</strong>；一般都是用bgsave</li><li>执行了bgsave命令，会创建一个子进程来生成 RDB 文件；</li></ul><ol start="2"><li>修改配置文件</li></ol><p>Redis 还可以通过配置文件的选项来实现每隔一段时间自动执行一次 bgsave 命令，默认会提供以下配置：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">save </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">900</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">save </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">300</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 10</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">save </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">60</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 10000</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>虽然配置文件的选项名叫 save，实际上执行的是 bgsave 命令，也就是会创建子进程来生成 RDB 快照文件。 只要满足上面条件的任意一个，就会执行bgsave，它们的意思分别是：</p><ul><li>900 秒之内，对数据库进行了至少 1 次修改；</li><li>300 秒之内，对数据库进行了至少 10 次修改；</li><li>60 秒之内，对数据库进行了至少 10000 次修改。</li></ul><blockquote><p>RDB 在执行快照的时候，数据能修改吗？</p></blockquote><p>可以的，执行 bgsave 过程中，Redis 依然<strong>可以继续处理操作命令</strong>的，也就是数据是能被修改的，关键的技术就在于<strong>写时复制技术（Copy-On-Write, COW）。</strong></p><p>执行 bgsave 命令的时候，会通过 fork() 创建子进程，此时子进程和父进程是共享同一片内存数据的，因为创建子进程的时候，会复制父进程的页表(虚拟内存和物理内存的映射)，但是页表指向的物理内存还是一个，此时如果主线程执行读操作，则主线程和 bgsave 子进程互相不影响。</p><img src="https://cdn.jsdelivr.net/gh/Cutewr/blogimage@main/img/image-20240830205757069.png" style="zoom:50%;display:block;margin:auto;"><p>如果主线程执行写操作，则被修改的数据会复制一份副本，然后 bgsave 子进程会把该副本数据写入 RDB 文件，在这个过程中，主线程仍然可以直接修改原来的数据。</p><img src="https://cdn.jsdelivr.net/gh/Cutewr/blogimage@main/img/image-20240830205805888.png" style="zoom:50%;display:block;margin:auto;"><p>这样的目的是为了减少创建子进程时的性能损耗，从而加快创建子进程的速度，毕竟创建子进程的过程中，是会阻塞主线程的。</p><p>所以，创建 bgsave 子进程后，由于共享父进程的所有内存数据，于是就可以直接读取主线程（父进程）里的内存数据，并将数据写入到 RDB 文件。</p><p>当主线程（父进程）对这些共享的内存数据也都是只读操作，那么，主线程（父进程）和 bgsave 子进程相互不影响。</p><p>但是，如果主线程（父进程）要<strong>修改共享数据里的某一块数据</strong>（比如键值对 <code>A</code>）时，就会发生写时复制，于是这块数据的<strong>物理内存就会被复制一份（键值对 <code>A&#39;</code>）</strong>，然后<strong>主线程在这个数据副本（键值对 <code>A&#39;</code>）进行修改操作</strong>。与此同时，<strong>bgsave 子进程可以继续把原来的数据（键值对 <code>A</code>）写入到 RDB 文件</strong>。</p><p>就是这样，Redis 使用 bgsave 对当前内存中的所有数据做快照，这个操作是由 bgsave 子进程在后台完成的，执行时不会阻塞主线程，这就使得主线程同时可以修改数据。</p><p>细心的同学，肯定发现了，bgsave 快照过程中，如果主线程修改了共享数据，<strong>发生了写时复制后，RDB 快照保存的是原本的内存数据</strong>，而主线程刚修改的数据，是没办法在这一时间写入 RDB 文件的，只能交由下一次的 bgsave 快照。</p><p>所以 Redis 在使用 bgsave 快照过程中，如果主线程修改了内存数据，不管是否是共享的内存数据，RDB 快照都无法写入主线程刚修改的数据，因为此时主线程（父进程）的内存数据和子进程的内存数据已经分离了，子进程写入到 RDB 文件的内存数据只能是原本的内存数据。</p><p>如果系统恰好在 RDB 快照文件创建完毕后崩溃了，那么 Redis 将会丢失主线程在快照期间修改的数据。</p><p>另外，写时复制的时候会出现这么个极端的情况。</p><p>在 Redis 执行 RDB 持久化期间，刚 fork 时，主进程和子进程共享同一物理内存，但是途中主进程处理了写操作，修改了共享内存，于是当前被修改的数据的物理内存就会被复制一份。</p><p>那么极端情况下，<strong>如果所有的共享内存都被修改，则此时的内存占用是原先的 2 倍。</strong></p><p>所以，针对写操作多的场景，我们要留意下快照过程中内存的变化，防止内存被占满了。</p><h3 id="rdb的优点和缺点总结" tabindex="-1"><a class="header-anchor" href="#rdb的优点和缺点总结"><span>RDB的优点和缺点总结</span></a></h3><p>优点：恢复数据的时候直接把RDB文件读入内存就可以，速度比较快</p><p>缺点：Redis 的快照是<strong>全量快照</strong>，就是每次执行快照，都是把内存中的所有数据都记录到磁盘中。如果频率太高，可能会对 Redis 性能产生影响。如果频率太低，服务器故障时，丢失的数据会很多。</p><h2 id="混合持久化方式" tabindex="-1"><a class="header-anchor" href="#混合持久化方式"><span>混合持久化方式</span></a></h2><p>RDB 优点是数据恢复速度快，但是快照的频率不好把握。频率太低，丢失的数据就会比较多，频率太高，就会影响性能。AOF 优点是丢失数据少，但是数据恢复不快。</p><p>为了集成了两者的优点， Redis 4.0 提出了混合持久化，既保证了Redis重启的数据恢复速度，又降低数据丢失风险。</p><p>混合持久化工作在 <strong>AOF 日志重写过程</strong>，当开启了混合持久化时，在 AOF 重写日志时，fork 出来的重写子进程会先将与主线程共享的内存数据以 RDB 方式写入到 AOF 文件，然后主线程处理的操作命令会被记录在重写缓冲区里，重写缓冲区里的增量命令会以 AOF 方式写入到 AOF 文件，写入完成后通知主进程将新的含有 RDB 格式和 AOF 格式的 AOF 文件替换旧的的 AOF 文件。</p><p>也就是说，使用了混合持久化，AOF 文件的<strong>前半部分是 RDB 格式的全量数据，后半部分是 AOF 格式的增量数据</strong>。</p><img src="https://cdn.jsdelivr.net/gh/Cutewr/blogimage@main/img/image-20240830205818626.png" style="zoom:67%;display:block;margin:auto;"><p>这样的好处在于，重启 Redis 加载数据的时候，由于前半部分是 RDB 内容，这样<strong>加载的时候速度会很快</strong>。</p><p>加载完 RDB 的内容后，才会加载后半部分的 AOF 内容，这里的内容是 Redis 后台子进程重写 AOF 期间，主线程处理的操作命令，可以使得<strong>数据更少的丢失</strong>。</p><p><strong>混合持久化优点：</strong></p><ul><li>混合持久化结合了 RDB 和 AOF 持久化的优点，开头为 RDB 的格式，使得 Redis 可以更快的启动，同时结合 AOF 的优点，有减低了大量数据丢失的风险。</li></ul><p><strong>混合持久化缺点：</strong></p><ul><li>AOF 文件中添加了 RDB 格式的内容，使得 AOF 文件的可读性变得很差；</li><li>兼容性差，如果开启混合持久化，那么此混合持久化 AOF 文件，就不能用在 Redis 4.0 之前版本了。</li></ul>',95)],l={},n=(0,s(6262).A)(l,[["render",function(e,i){return(0,t.uX)(),(0,t.CE)("div",null,a)}]]),r=JSON.parse('{"path":"/DataBase/Redis/RedisPersistence.html","title":"Redis持久化","lang":"zh-CN","frontmatter":{"date":"2024-08-30T00:00:00.000Z","category":["数据库"],"tag":["Redis"],"description":"Redis持久化 Redis 如何实现数据不丢失？ Redis 的读写操作都是在内存中，所以 Redis 性能才会高。但是当 Redis宕机或者重启后，内存中的数据就会丢失，那Redis 实现了数据持久化的机制，把数据存储到磁盘，这样Redis重启后就能够从磁盘中恢复原有的数据。 Redis 共有三种数据持久化的方式： AOF 日志：每执行一条写操作命...","head":[["meta",{"property":"og:url","content":"https://cutewr.github.io/DataBase/Redis/RedisPersistence.html"}],["meta",{"property":"og:site_name","content":"首页"}],["meta",{"property":"og:title","content":"Redis持久化"}],["meta",{"property":"og:description","content":"Redis持久化 Redis 如何实现数据不丢失？ Redis 的读写操作都是在内存中，所以 Redis 性能才会高。但是当 Redis宕机或者重启后，内存中的数据就会丢失，那Redis 实现了数据持久化的机制，把数据存储到磁盘，这样Redis重启后就能够从磁盘中恢复原有的数据。 Redis 共有三种数据持久化的方式： AOF 日志：每执行一条写操作命..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://cdn.jsdelivr.net/gh/Cutewr/blogimage@main/img/image-20240830205701133.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-08-31T00:18:55.000Z"}],["meta",{"property":"article:author","content":"Cutewr"}],["meta",{"property":"article:tag","content":"Redis"}],["meta",{"property":"article:published_time","content":"2024-08-30T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-08-31T00:18:55.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Redis持久化\\",\\"image\\":[\\"https://cdn.jsdelivr.net/gh/Cutewr/blogimage@main/img/image-20240830205701133.png\\"],\\"datePublished\\":\\"2024-08-30T00:00:00.000Z\\",\\"dateModified\\":\\"2024-08-31T00:18:55.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Cutewr\\",\\"url\\":\\"https://cutewr.github.io\\"}]}"]]},"headers":[{"level":2,"title":"Redis 如何实现数据不丢失？","slug":"redis-如何实现数据不丢失","link":"#redis-如何实现数据不丢失","children":[]},{"level":2,"title":"AOF 日志","slug":"aof-日志","link":"#aof-日志","children":[{"level":3,"title":"简介","slug":"简介","link":"#简介","children":[]},{"level":3,"title":"AOF写回策略","slug":"aof写回策略","link":"#aof写回策略","children":[]},{"level":3,"title":"AOF 重写机制","slug":"aof-重写机制","link":"#aof-重写机制","children":[]}]},{"level":2,"title":"RDB 快照方式","slug":"rdb-快照方式","link":"#rdb-快照方式","children":[{"level":3,"title":"简介","slug":"简介-1","link":"#简介-1","children":[]},{"level":3,"title":"怎么生成RDB文件","slug":"怎么生成rdb文件","link":"#怎么生成rdb文件","children":[]},{"level":3,"title":"RDB的优点和缺点总结","slug":"rdb的优点和缺点总结","link":"#rdb的优点和缺点总结","children":[]}]},{"level":2,"title":"混合持久化方式","slug":"混合持久化方式","link":"#混合持久化方式","children":[]}],"git":{"createdTime":1725063535000,"updatedTime":1725063535000,"contributors":[{"name":"Cutewr","email":"2574303446@qq.com","commits":1}]},"readingTime":{"minutes":14.75,"words":4425},"filePathRelative":"DataBase/Redis/RedisPersistence.md","localizedDate":"2024年8月30日","excerpt":"\\n<h2>Redis 如何实现数据不丢失？</h2>\\n<p>Redis 的读写操作都是在内存中，所以 Redis 性能才会高。但是当 Redis宕机或者重启后，内存中的数据就会丢失，那Redis 实现了数据持久化的机制，把数据存储到磁盘，这样Redis重启后就能够从磁盘中恢复原有的数据。</p>\\n<p>Redis 共有三种数据持久化的方式：</p>\\n<ul>\\n<li><strong>AOF 日志</strong>：每执行一条写操作命令，就把该命令以追加的方式写入到一个文件里；</li>\\n<li><strong>RDB 快照</strong>：将某一时刻的内存数据，以二进制的方式写入磁盘；</li>\\n<li><strong>混合持久化方式</strong>：Redis 4.0 新增的方式，集成了 AOF 和 RBD 的优点；</li>\\n</ul>","autoDesc":true}')}}]);