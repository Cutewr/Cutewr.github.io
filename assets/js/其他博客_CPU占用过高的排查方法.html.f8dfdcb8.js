"use strict";(self.webpackChunkvuepress_theme_hope_template=self.webpackChunkvuepress_theme_hope_template||[]).push([[9108],{6262:(t,e)=>{e.A=(t,e)=>{const l=t.__vccOpts||t;for(const[t,a]of e)l[t]=a;return l}},4346:(t,e,l)=>{l.r(e),l.d(e,{comp:()=>p,data:()=>o});var a=l(641);const n=[(0,a.Fv)('<h1 id="cpu占用过高-怎么排查" tabindex="-1"><a class="header-anchor" href="#cpu占用过高-怎么排查"><span>CPU占用过高，怎么排查？</span></a></h1><h2 id="出现问题的原因" tabindex="-1"><a class="header-anchor" href="#出现问题的原因"><span><strong>出现问题的原因</strong></span></a></h2><p>一种是由计算导致的CPU使用过高，一种是由内存不足，频繁垃圾回收导致的CPU使用过高。</p><ol><li>线程太多，上下文不停切换，比如大量线程激烈的锁竞争，线程不停阻塞恢复阻塞。或者产生死锁</li><li>项目出现死循环，比如hashmap并发场景下的死循环</li><li>频繁发生FULL GC</li></ol><h2 id="排查步骤" tabindex="-1"><a class="header-anchor" href="#排查步骤"><span><strong>排查步骤</strong></span></a></h2><ol><li><p>执行 top 命令，在linux系统上显示系统各个进程的资源占用状态，找到占用率很高的进程ID 1024</p></li><li><p>执行 top -p 1024 -H 命令，查看当前进程下的所有线程信息，找到占用率很高的线程ID 2048，将ID转换成16进制得到800</p></li><li><p>执行 jstack 1024&gt; thread_stack.log 将进程的堆栈信息写入到文件中</p></li><li><p>在thread_stack.log根据找到800对应的堆栈信息，根据堆栈信息定位到代码位置</p></li><li><p>如果线程为GC线程（VM Thread），使用 jmap -histo&gt; jmap.log 输出java堆中对象的统计信息，可能不停创建大对象，导致频繁GC导致CPU占用很高。或者使用jmap导出dump日志，使用mat工具查看，如果内存使用率不高，但FULL GC频繁，可能是手动调用System.gc()导致的。</p></li></ol><h2 id="特殊情况" tabindex="-1"><a class="header-anchor" href="#特殊情况"><span><strong>特殊情况</strong></span></a></h2><ol><li>不定期出现的接口耗时现象</li></ol><p>接口偶尔会出现响应很慢的情况，思路是通过压测工具不断加大访问力度，那么大多数线程最终会阻塞在问题点，通过这些线程的堆栈信息，找到对应位置</p><ol start="2"><li>死锁</li></ol><p>jsatck会自动检测出死锁</p><h2 id="小结" tabindex="-1"><a class="header-anchor" href="#小结"><span><strong>小结</strong></span></a></h2><ul><li><strong>高CPU占用排查步骤</strong></li></ul><ol><li>TOP命令找到CPU使用率最高的进程和其线程信息，将线程id转化成16进制</li><li>jsatck 进程 打印进程的堆栈信息，根据线程id找到问题线程和它的堆栈信息，分析处理</li></ol><ul><li><strong>高内存占用排查步骤</strong></li></ul><ol><li>TOP命令找到占用内存最高的进程</li><li>jmap -histo 进程ID 输出进程内对象统计信息，找出问题对象，代码中定位到对象创建位置</li><li>或者jmap导出dump日志，使用mat工具查看</li></ol><ul><li><strong>堆外内存泄漏排查</strong></li></ul><p>使用gdb、strace等工具</p>',18)],i={},p=(0,l(6262).A)(i,[["render",function(t,e){return(0,a.uX)(),(0,a.CE)("div",null,n)}]]),o=JSON.parse('{"path":"/%E5%85%B6%E4%BB%96%E5%8D%9A%E5%AE%A2/CPU%E5%8D%A0%E7%94%A8%E8%BF%87%E9%AB%98%E7%9A%84%E6%8E%92%E6%9F%A5%E6%96%B9%E6%B3%95.html","title":"CPU占用过高，怎么排查？","lang":"zh-CN","frontmatter":{"date":"2024-09-07T00:00:00.000Z","category":["问题排查"],"description":"CPU占用过高，怎么排查？ 出现问题的原因 一种是由计算导致的CPU使用过高，一种是由内存不足，频繁垃圾回收导致的CPU使用过高。 线程太多，上下文不停切换，比如大量线程激烈的锁竞争，线程不停阻塞恢复阻塞。或者产生死锁 项目出现死循环，比如hashmap并发场景下的死循环 频繁发生FULL GC 排查步骤 执行 top 命令，在linux系统上显示系统...","head":[["meta",{"property":"og:url","content":"https://cutewr.github.io/%E5%85%B6%E4%BB%96%E5%8D%9A%E5%AE%A2/CPU%E5%8D%A0%E7%94%A8%E8%BF%87%E9%AB%98%E7%9A%84%E6%8E%92%E6%9F%A5%E6%96%B9%E6%B3%95.html"}],["meta",{"property":"og:site_name","content":"首页"}],["meta",{"property":"og:title","content":"CPU占用过高，怎么排查？"}],["meta",{"property":"og:description","content":"CPU占用过高，怎么排查？ 出现问题的原因 一种是由计算导致的CPU使用过高，一种是由内存不足，频繁垃圾回收导致的CPU使用过高。 线程太多，上下文不停切换，比如大量线程激烈的锁竞争，线程不停阻塞恢复阻塞。或者产生死锁 项目出现死循环，比如hashmap并发场景下的死循环 频繁发生FULL GC 排查步骤 执行 top 命令，在linux系统上显示系统..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-09-07T09:16:10.000Z"}],["meta",{"property":"article:author","content":"Cutewr"}],["meta",{"property":"article:published_time","content":"2024-09-07T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-09-07T09:16:10.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"CPU占用过高，怎么排查？\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-09-07T00:00:00.000Z\\",\\"dateModified\\":\\"2024-09-07T09:16:10.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Cutewr\\",\\"url\\":\\"https://cutewr.github.io\\"}]}"]]},"headers":[{"level":2,"title":"出现问题的原因","slug":"出现问题的原因","link":"#出现问题的原因","children":[]},{"level":2,"title":"排查步骤","slug":"排查步骤","link":"#排查步骤","children":[]},{"level":2,"title":"特殊情况","slug":"特殊情况","link":"#特殊情况","children":[]},{"level":2,"title":"小结","slug":"小结","link":"#小结","children":[]}],"git":{"createdTime":1725700570000,"updatedTime":1725700570000,"contributors":[{"name":"Cutewr","email":"2574303446@qq.com","commits":1}]},"readingTime":{"minutes":2.05,"words":614},"filePathRelative":"其他博客/CPU占用过高的排查方法.md","localizedDate":"2024年9月7日","excerpt":"\\n<h2><strong>出现问题的原因</strong></h2>\\n<p>一种是由计算导致的CPU使用过高，一种是由内存不足，频繁垃圾回收导致的CPU使用过高。</p>\\n<ol>\\n<li>线程太多，上下文不停切换，比如大量线程激烈的锁竞争，线程不停阻塞恢复阻塞。或者产生死锁</li>\\n<li>项目出现死循环，比如hashmap并发场景下的死循环</li>\\n<li>频繁发生FULL GC</li>\\n</ol>\\n<h2><strong>排查步骤</strong></h2>\\n<ol>\\n<li>\\n<p>执行&nbsp;top&nbsp;命令，在linux系统上显示系统各个进程的资源占用状态，找到占用率很高的进程ID 1024</p>\\n</li>\\n<li>\\n<p>执行&nbsp;top -p 1024 -H&nbsp;命令，查看当前进程下的所有线程信息，找到占用率很高的线程ID 2048，将ID转换成16进制得到800</p>\\n</li>\\n<li>\\n<p>执行&nbsp;jstack 1024&gt; thread_stack.log&nbsp;将进程的堆栈信息写入到文件中</p>\\n</li>\\n<li>\\n<p>在thread_stack.log根据找到800对应的堆栈信息，根据堆栈信息定位到代码位置</p>\\n</li>\\n<li>\\n<p>如果线程为GC线程（VM Thread），使用&nbsp;jmap -histo&gt; jmap.log&nbsp;输出java堆中对象的统计信息，可能不停创建大对象，导致频繁GC导致CPU占用很高。或者使用jmap导出dump日志，使用mat工具查看，如果内存使用率不高，但FULL GC频繁，可能是手动调用System.gc()导致的。</p>\\n</li>\\n</ol>","autoDesc":true}')}}]);